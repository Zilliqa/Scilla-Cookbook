"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4847],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var u=r.createContext({}),s=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=s(e.components);return r.createElement(u.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(n),f=a,d=m["".concat(u,".").concat(f)]||m[f]||p[f]||i;return n?r.createElement(d,o(o({ref:t},c),{},{components:n})):r.createElement(d,o({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=m;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var s=2;s<i;s++)o[s]=n[s];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},1189:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return c},default:function(){return m}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],l={tags:["option","optional","some","none","divide","percentage"]},u="Safe Mutiplication",s={unversionedId:"recipes/scilla-contract/safemutiply",id:"recipes/scilla-contract/safemutiply",isDocsHomePage:!1,title:"Safe Mutiplication",description:"When your are working with numbers in any programming language you are subject to overflows. An overflow happens when the value of number is bigger than the maximum possible value offered by the machine.",source:"@site/docs/recipes/scilla-contract/safemutiply.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/safemutiply",permalink:"/recipes/scilla-contract/safemutiply",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-contract/safemutiply.md",tags:[{label:"option",permalink:"/tags/option"},{label:"optional",permalink:"/tags/optional"},{label:"some",permalink:"/tags/some"},{label:"none",permalink:"/tags/none"},{label:"divide",permalink:"/tags/divide"},{label:"percentage",permalink:"/tags/percentage"}],version:"current",frontMatter:{tags:["option","optional","some","none","divide","percentage"]},sidebar:"tutorialSidebar",previous:{title:"Remote State Reads (RSR)",permalink:"/recipes/scilla-contract/remoteread"},next:{title:"U/int",permalink:"/recipes/scilla-contract/uint"}},c=[{value:"Safe Percentage",id:"safe-percentage",children:[]},{value:"Further Reading",id:"further-reading",children:[]}],p={toc:c};function m(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"safe-mutiplication"},"Safe Mutiplication"),(0,i.kt)("p",null,"When your are working with numbers in any programming language you are subject to overflows. An overflow happens when the value of number is bigger than the maximum possible value offered by the machine."),(0,i.kt)("p",null,"For example if you\u2019re using an unsigned integer in Scilla. The possible values of your variable ranges from 0 to  2^256 (1.1579209e+77). So it means that if you\u2019re around the maximum value and increment your variable it will error as it overflows the maximum value range."),(0,i.kt)("p",null,"If developers want to mutiple two ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint128")," together, they should firstly upcast their current values into ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint256")," so it doesn't overflow, and then perform the mutiplication, finally downcasting the value to a ",(0,i.kt)("inlineCode",{parentName:"p"},"Uint128")," after performing the division."),(0,i.kt)("h2",{id:"safe-percentage"},"Safe Percentage"),(0,i.kt)("p",null,"If you are working with trying to find the percentage value of a users share of a pool and then reward them based on that percentage, then consider using safe ",(0,i.kt)("inlineCode",{parentName:"p"},"muldiv"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'let uint128_to_uint256 : Uint128 -> Uint256 =\n  fun (x : Uint128) =>\n    let ox256 = builtin to_uint256 x in\n      match ox256 with\n      | None =>\n        (* this never happens, hence we throw a division by zero exception just in case *)\n        let zero = Uint256 0 in\n        builtin div zero zero\n      | Some x256 => x256\n      end\n    \n\n(* Compute "(x * y) / z" with protection against integer overflows *)\nlet muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =\n    fun (x : Uint128) =>\n    fun (y : Uint128) =>\n    fun (z : Uint128) =>\n      let x256 = uint128_to_uint256 x in\n      let y256 = uint128_to_uint256 y in\n      let z256 = uint128_to_uint256 z in\n      let x_mul_y256 = builtin mul x256 y256 in\n      let res256 = builtin div x_mul_y256 z256 in\n      let ores128 = builtin to_uint128 res256 in\n      match ores128 with\n      | None =>\n        (* this must never happen, hence we throw an integer overflow exception *)\n        let max_uint128 = Uint128 340282366920938463463374607431768211455 in\n        let fourtytwo128 = Uint128 42 in\n        builtin mul max_uint128 fourtytwo128\n      | Some res128 =>\n        res128\n      end\n')),(0,i.kt)("p",null,"Lets assume we are A. The pool has the following entries."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A 12"),(0,i.kt)("li",{parentName:"ul"},"B 3"),(0,i.kt)("li",{parentName:"ul"},"C 9"),(0,i.kt)("li",{parentName:"ul"},"D 69")),(0,i.kt)("p",null,"We can deduce and reason the following."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A own's 12"),(0,i.kt)("li",{parentName:"ul"},"The total of all the entries is 93"),(0,i.kt)("li",{parentName:"ul"},"12 is x percentage of 93 = 12.9"),(0,i.kt)("li",{parentName:"ul"},"If the total rewards is 100Z or 100000000000000 QA"),(0,i.kt)("li",{parentName:"ul"},"Then A is owed 12.9Z or 12903225806451 QA")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"user_share = 12 \ntotal_amount_rewards = 100000000000000qa\nsum_of_all_shares = 93\n")),(0,i.kt)("p",null,"Usage of ",(0,i.kt)("inlineCode",{parentName:"p"},"muldiv")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"user_share_of_rewards = muldiv user_share total_amount_rewards sum_of_all_shares;\n")),(0,i.kt)("p",null,"Test this out on isolated environment ",(0,i.kt)("inlineCode",{parentName:"p"},"0xd3360fe70a19dc2dd5cb7ad4164db455ddc2a68c")),(0,i.kt)("h2",{id:"further-reading"},"Further Reading"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/staking-contract/blob/82fad745a04eedefb1a0cd16e5316626c3736c13/contracts/ssnlist.scilla"},"SSN Staking Contract")))}m.isMDXComponent=!0}}]);