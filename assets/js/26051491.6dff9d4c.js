"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4298],{3905:function(n,e,t){t.d(e,{Zo:function(){return u},kt:function(){return d}});var i=t(7294);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function a(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,i)}return t}function l(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?a(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,i,r=function(n,e){if(null==n)return{};var t,i,r={},a=Object.keys(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(i=0;i<a.length;i++)t=a[i],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var s=i.createContext({}),c=function(n){var e=i.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):l(l({},e),n)),t},u=function(n){var e=c(n.components);return i.createElement(s.Provider,{value:e},n.children)},f={inlineCode:"code",wrapper:function(n){var e=n.children;return i.createElement(i.Fragment,{},e)}},p=i.forwardRef((function(n,e){var t=n.components,r=n.mdxType,a=n.originalType,s=n.parentName,u=o(n,["components","mdxType","originalType","parentName"]),p=c(t),d=r,m=p["".concat(s,".").concat(d)]||p[d]||f[d]||a;return t?i.createElement(m,l(l({ref:e},u),{},{components:t})):i.createElement(m,l({ref:e},u))}));function d(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var a=t.length,l=new Array(a);l[0]=p;var o={};for(var s in e)hasOwnProperty.call(e,s)&&(o[s]=e[s]);o.originalType=n,o.mdxType="string"==typeof n?n:r,l[1]=o;for(var c=2;c<a;c++)l[c]=t[c];return i.createElement.apply(null,l)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},6793:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var i=t(7462),r=t(3366),a=(t(7294),t(3905)),l=["components"],o={tags:["folding","recursion","iterate"]},s="Folding",c={unversionedId:"recipes/scilla-contract/folding",id:"recipes/scilla-contract/folding",isDocsHomePage:!1,title:"Folding",description:'Recursion in Scilla is presented by means of "folds" or structural traversals. To see how they are expressed, let us take a look at some Scilla.',source:"@site/docs/recipes/scilla-contract/folding.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/folding",permalink:"/recipes/scilla-contract/folding",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/docs/recipes/scilla-contract/folding.md",tags:[{label:"folding",permalink:"/tags/folding"},{label:"recursion",permalink:"/tags/recursion"},{label:"iterate",permalink:"/tags/iterate"}],version:"current",frontMatter:{tags:["folding","recursion","iterate"]},sidebar:"tutorialSidebar",previous:{title:"Decentralised Exchange (DEX)",permalink:"/recipes/scilla-contract/dex"},next:{title:"Funds",permalink:"/recipes/scilla-contract/funds"}},u=[{value:"Polymorphic specifications for folds",id:"polymorphic-specifications-for-folds",children:[]},{value:"Fibonacci folding example",id:"fibonacci-folding-example",children:[]},{value:"Recursion example",id:"recursion-example",children:[]},{value:"Further Reading",id:"further-reading",children:[]}],f={toc:u};function p(n){var e=n.components,t=(0,r.Z)(n,l);return(0,a.kt)("wrapper",(0,i.Z)({},f,t,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"folding"},"Folding"),(0,a.kt)("p",null,'Recursion in Scilla is presented by means of "folds" or structural traversals. To see how they are expressed, let us take a look at some Scilla.'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"type nat = Zero | Succ of nat\n")),(0,a.kt)("p",null,'The following two library functions perform left/right folding over a natural number, with an "accumulator" z and an iterator f'),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let rec nat_fold_left f z n =\n  match n with\n    | Zero -> z\n    | Succ n' ->\n      let res = f z n' in\n      nat_fold_left f res n'\n\nlet rec nat_fold_right f z n =\n  match n with\n    | Zero -> z\n    | Succ n' ->\n      let res = nat_fold_right f z n' in\n      f n' res\n")),(0,a.kt)("p",null,'Even though they are equivalent modulo the order of formals in f, nat_fold_left makes it easier to map the intuition "forward" iteration, which passes a modified accumulator further (i.e., the combination is performed on the forward step of the recursion), while nat_fold_right is better for "backwards" iteration, when the result is assembled based on what\'s accumulated in the later calls (i.e., the combination is performed on the backwards step of the recursion).'),(0,a.kt)("h2",{id:"polymorphic-specifications-for-folds"},"Polymorphic specifications for folds"),(0,a.kt)("p",null,"Notice that folds are polymorphic functions, as they can be instantiated with iterators of multiple different types. For instance, the type of nat_fold is forall 'T, ('T -> Nat -> 'T) -> 'T -> Nat -> 'T, where the type variable 'T accounts for the type of the accumulator and the final results."),(0,a.kt)("p",null,"Therefore, before being applied to arguments, folds need to be instantiated with argument types (those might themselves be type variables, if a fold is used within a body of a polymorphically-typed function, binding another type variable). For instance, in one of the examples below, nat_fold is instantiated before it is applied as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let typed_folder = @nat_fold (Product Int Int) in\n(* Using folder as a function of type nat -> (Product Int Int) *)\nlet folder = typed_folder iter_fun init_val in \n")),(0,a.kt)("p",null,"Similarly, the types for folds over the lists are as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"list_foldl: forall 'A . forall 'B . ('B -> 'A -> 'B) -> 'B -> (List 'A) -> 'B\nlist_foldr: forall 'A . forall 'B . ('A -> 'B -> 'B) -> 'B -> (List 'A) -> 'B\n")),(0,a.kt)("h2",{id:"fibonacci-folding-example"},"Fibonacci folding example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let fib = fun (n : Nat) =>\n  let iter_fun =\n    fun (res : Product Int Int) => fun (n: Nat) =>\n      match res with\n      | Pair x y => let z = builtin add x y in Pair {Int Int} z x\n      end\n    in\n  let zero = 0 in\n  let one = 1 in\n  let init_val = Pair {Int Int} one zero in\n  let typed_folder = @nat_fold (Product Int Int) in\n  let folder = typed_folder iter_fun init_val in\n  let res = folder n in\n  match res with | Pair x y => x end\n")),(0,a.kt)("h2",{id:"recursion-example"},"Recursion example"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},'(* Two examples how to implement recursive function calls using\n   nat_fold and the builtin ADT Nat\n   1) Adapted version of an example by Amrit that uses\n    recursion to build a list [m, m+1, ..., n-2, n-1] where\n    m and n are parameters\n   2) Compute the factorial of a parameter n:\n    n! = 0 if n=0,\n    n! = n * (n-1) * ... * 1 if n>0                              *)\n\nscilla_version 0\n\nimport IntUtils NatUtils\n\nlibrary Recursion\n\nlet zero32 = Uint32 0\nlet one32 = Uint32 1\nlet empty_list = Nil {Uint32}\n\nlet build_list : Uint32 -> Uint32 -> List Uint32 =\n  fun (m : Uint32) =>\n  fun (n : Uint32) =>\n    let m_lt_n = builtin lt m n in (* if m >= n the list is empty *)\n    match m_lt_n with\n    | True =>\n        let delta = builtin sub n m in\n        let delta_nat = builtin to_nat delta in\n        let acc_init = Pair {(List Uint32) Uint32} empty_list n in\n        let one = Uint32 1 in\n        let step =\n          fun (xs_n : Pair (List Uint32) Uint32) =>\n          fun (ignore : Nat) =>\n          match xs_n with\n          | Pair xs n =>\n              let new_n = builtin sub n one in\n              let new_xs = Cons {Uint32} new_n xs in\n              Pair {(List Uint32) Uint32} new_xs new_n\n          end in\n        let fold = @nat_fold (Pair (List Uint32) Uint32) in (* from NatUtils *)\n        let xs_m = fold step acc_init delta_nat in\n        match xs_m with\n        | Pair xs m => xs\n        end\n    | False => empty_list\n    end (* m_lt_n *)\n\nlet factorial : Uint32 ->  Uint32 =\n  fun (n : Uint32) =>\n    let is_n_gt_zero = uint32_gt n zero32 in\n    match is_n_gt_zero with\n    | False => one32 (* 0!=1 *)\n    | True => (* res = res * (n-1) unless n=1 then res = res *)\n      let n_nat = builtin to_nat n in\n      let acc_init = Pair {Uint32 Uint32} n n in\n      let step =\n        fun (current_acc : Pair Uint32 Uint32) =>\n        fun (previous : Nat) =>\n        let previous_int = nat_to_int previous in\n        match current_acc with\n        | Pair res n =>\n          (* nat_fold goes down to Zero, need to stop at 1 *)\n          let multiplier =\n            let is_zero = is_some_zero previous in (* from NatUtils *)\n            match is_zero with\n            | True => one32\n            | False => previous_int\n            end in (* is_zero *)\n          let new_res = builtin mul res multiplier in\n          Pair {Uint32 Uint32} new_res previous_int\n        end in\n      let fold = @nat_fold (Pair Uint32 Uint32) in (* from NatUtils *)\n      let result_pair = fold step acc_init n_nat in\n      match result_pair with\n      | Pair result n => result\n      end\n    end\n\n\ncontract Recursion()\n\n(* create the list [m, m+1, ..., n-1] *)\ntransition CreateList(m : Uint32, n : Uint32)\n l = build_list m n;\n e = {_eventname : "CreateList"; list : l};\n event e\nend\n\n(* compute n! *)\ntransition Factorial(n: Uint32)\n  f = factorial n;\n  e = {_eventname: "Factorial"; n: n; n_factorial: f};\n  event e\nend\n')),(0,a.kt)("h2",{id:"further-reading"},"Further Reading"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/TheDrBee/oSCILLAtor/blob/main/contracts/Recursion.scilla"},"TheDrBee - Recursion.scilla")))}p.isMDXComponent=!0}}]);