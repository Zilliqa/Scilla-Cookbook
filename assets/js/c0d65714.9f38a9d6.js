"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4383],{3905:function(e,t,r){r.d(t,{Zo:function(){return d},kt:function(){return y}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function l(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},s=Object.keys(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)r=s[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var o=n.createContext({}),c=function(e){var t=n.useContext(o),r=t;return e&&(r="function"==typeof e?e(t):l(l({},t),e)),r},d=function(e){var t=c(e.components);return n.createElement(o.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,s=e.originalType,o=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),p=c(r),y=a,b=p["".concat(o,".").concat(y)]||p[y]||u[y]||s;return r?n.createElement(b,l(l({ref:t},d),{},{components:r})):n.createElement(b,l({ref:t},d))}));function y(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=r.length,l=new Array(s);l[0]=p;var i={};for(var o in t)hasOwnProperty.call(t,o)&&(i[o]=t[o]);i.originalType=e,i.mdxType="string"==typeof e?e:a,l[1]=i;for(var c=2;c<s;c++)l[c]=r[c];return n.createElement.apply(null,l)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},1746:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return o},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var n=r(7462),a=r(3366),s=(r(7294),r(3905)),l=["components"],i={tags:["Address","ByStr20","Bech32","Base16"]},o="Addresses",c={unversionedId:"recipes/scilla-contract/addresses",id:"recipes/scilla-contract/addresses",isDocsHomePage:!1,title:"Addresses",description:"Addresses on the network can either be a wallet or a contract.",source:"@site/docs/recipes/scilla-contract/addresses.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/addresses",permalink:"/recipes/scilla-contract/addresses",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-contract/addresses.md",tags:[{label:"Address",permalink:"/tags/address"},{label:"ByStr20",permalink:"/tags/by-str-20"},{label:"Bech32",permalink:"/tags/bech-32"},{label:"Base16",permalink:"/tags/base-16"}],version:"current",frontMatter:{tags:["Address","ByStr20","Bech32","Base16"]},sidebar:"tutorialSidebar",previous:{title:"Community Scilla Cookbook",permalink:"/"},next:{title:"ADT",permalink:"/recipes/scilla-contract/adt"}},d=[{value:"Address Subtypes",id:"address-subtypes",children:[]},{value:"ByStr20 Library Functions",id:"bystr20-library-functions",children:[{value:"equalByStr20",id:"equalbystr20",children:[]}]},{value:"Further Reading",id:"further-reading",children:[]}],u={toc:d};function p(e){var t=e.components,r=(0,a.Z)(e,l);return(0,s.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"addresses"},"Addresses"),(0,s.kt)("p",null,"Addresses on the network can either be a wallet or a contract."),(0,s.kt)("p",null,"Addresses come in two notations Bech32 or Base16."),(0,s.kt)("p",null,"Bech32's start with the prefix ",(0,s.kt)("inlineCode",{parentName:"p"},"zil...")," whereas Base16's are prefixed with ",(0,s.kt)("inlineCode",{parentName:"p"},"0x..."),"."),(0,s.kt)("p",null,"Converting a Bech32 into a Base16 and visa versa can be achieved manually though ",(0,s.kt)("inlineCode",{parentName:"p"},"IDE>Tools>AddressConverter")," or programatically using programs like Zilliqa-JS."),(0,s.kt)("p",null,"When we refer to a ByStr20 in Scilla, we refer to the Base16 address."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-text"},"Bech32 = zil1zyg3zyg3zyg3zyg3zyg3zyg3zyg3zyg3h6785s\nBase16 = 0x1111111111111111111111111111111111111111\n")),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ocaml"},"scilla_version 0\n\nlibrary Example\n\nlet constant_bystr = 0x1111111111111111111111111111111111111111\n\ncontract Example\n(\n    immutable_bystr: BNum\n)\n\nfield state_bystr : ByStr20 = constant_bystr\n")),(0,s.kt)("h2",{id:"address-subtypes"},"Address Subtypes"),(0,s.kt)("p",null,"We can infer subtypes of Address such as 'A contract on the network' or 'A user or contract on the network' to give some type safety when trying to use contracts or addresses that might not exist"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ocaml"},"  (* any valid bytes of string length 20, not guaranteed to be valid *)\n  ByStr20\n  (* guarantees to be either a contract or a user with some balance or nonce >= 1*)\n  ByStr20 with end\n  (* guarantees to be a contract *)\n  ByStr20 with contract end\n")),(0,s.kt)("p",null,"Read more on ",(0,s.kt)("a",{parentName:"p",href:"https://scilla.readthedocs.io/en/latest/scilla-in-depth.html?highlight=with%20end#address-subtyping"},"Address subtyping here.")),(0,s.kt)("h2",{id:"bystr20-library-functions"},"ByStr20 Library Functions"),(0,s.kt)("h3",{id:"equalbystr20"},"equalByStr20"),(0,s.kt)("p",null,"equalByStr20 is a library function that takes two addresses and returns ",(0,s.kt)("inlineCode",{parentName:"p"},"True")," from ",(0,s.kt)("inlineCode",{parentName:"p"},"builtin eq")," if the addresses are equal."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-ocaml"},"let eqByStr20 =\n  fun(bs1: ByStr20) =>\n  fun(bs2: ByStr20) =>\n    builtin eq bs1 bs2\n")),(0,s.kt)("h2",{id:"further-reading"},"Further Reading"),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://scilla.readthedocs.io/en/latest/scilla-in-depth.html?highlight=bystr20#addresses"},"readthedocs - Addresses")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/scilla/blob/master/tests/contracts/auction.scilla"},"auction.scilla")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/zli/blob/c35fbac35edb5c6987b8a5881490a7cacb4cb1be/testsuite/contracts/UnstoppableDomains/Registry.scilla"},"unstoppabledomains_registry.scilla")))}p.isMDXComponent=!0}}]);