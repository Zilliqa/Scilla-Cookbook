"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[1639],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var r=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},d=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(t),m=a,f=d["".concat(c,".").concat(m)]||d[m]||u[m]||i;return t?r.createElement(f,o(o({ref:n},p),{},{components:t})):r.createElement(f,o({ref:n},p))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=d;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<i;l++)o[l]=t[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},8585:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var r=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],s={tags:["non","fungible","token","reference","contract","zrc-1"]},c="Non-fungible token",l={unversionedId:"recipes/scilla-recipes/nonfungible",id:"recipes/scilla-recipes/nonfungible",isDocsHomePage:!1,title:"Non-fungible token",description:"A fungible token is unit of currency that can be readily interchanged, it has properties like fiat where 1 unit of currency is equal to 1 unit of the same currency.",source:"@site/docs/recipes/scilla-recipes/nonfungible.md",sourceDirName:"recipes/scilla-recipes",slug:"/recipes/scilla-recipes/nonfungible",permalink:"/recipes/scilla-recipes/nonfungible",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-recipes/nonfungible.md",tags:[{label:"non",permalink:"/tags/non"},{label:"fungible",permalink:"/tags/fungible"},{label:"token",permalink:"/tags/token"},{label:"reference",permalink:"/tags/reference"},{label:"contract",permalink:"/tags/contract"},{label:"zrc-1",permalink:"/tags/zrc-1"}],version:"current",frontMatter:{tags:["non","fungible","token","reference","contract","zrc-1"]},sidebar:"tutorialSidebar",previous:{title:"Natural numbers",permalink:"/recipes/scilla-recipes/natural"},next:{title:"Notable contracts",permalink:"/recipes/scilla-recipes/notable-contracts"}},p=[{value:"How does it work?",id:"how-does-it-work",children:[]},{value:"Types of non fungible contracts",id:"types-of-non-fungible-contracts",children:[{value:"ZRC-1",id:"zrc-1",children:[]},{value:"ZRC-6",id:"zrc-6",children:[]}]},{value:"Transfering Nonfungible Tokens",id:"transfering-nonfungible-tokens",children:[{value:"ZRC-7",id:"zrc-7",children:[]}]},{value:"Further reading",id:"further-reading",children:[]}],u={toc:p};function d(e){var n=e.components,t=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"non-fungible-token"},"Non-fungible token"),(0,i.kt)("p",null,"A ",(0,i.kt)("a",{parentName:"p",href:"fungible"},"fungible token")," is unit of currency that can be readily interchanged, it has properties like fiat where 1 unit of currency is equal to 1 unit of the same currency."),(0,i.kt)("p",null,"Non-fungible tokens have associated with it some unique properties like some particular attributes, image, asset and therefore makes each piece unique. The tokens can be thought of as certificates of ownership for virtual or physical assets. A Non-Fungible contract is a collection of associations between token ids, there associated asset and an owning address."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-1.md"},"ZRC-1")," defines a minimum interface a smart contract must implement to allow unique tokens to be managed, tracked, owned, and traded - it's a simple interface to attach a resource link to a token."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-6.md"},"ZRC-6")," defines another interface which has features to align itself with some of the patterns ERC-721 and ERC-1155 have such as royalty payments and batch minting."),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-7.md"},"ZRC-7")," defines a metadata standard that developers should follow. The resource attached to a ZRC-1 / ZRC-6 should emit a JSON response which contains not only the image, but the traits and other relevenat project and token infomation which ecosystem partners can then universally consume."),(0,i.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,i.kt)("p",null,"The non fungible contract has a state map called ",(0,i.kt)("inlineCode",{parentName:"p"},"token_owners")," which associates an incrementing ",(0,i.kt)("inlineCode",{parentName:"p"},"token_id")," to an address. The token has a concept of a ",(0,i.kt)("inlineCode",{parentName:"p"},"token_uri")," which it associates with the ",(0,i.kt)("inlineCode",{parentName:"p"},"token_id")," this is typically a JSON asset on the internet, ipfs, arweave and could hold any particular file. Only the ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_owner"),' is able to mint, however the contract has a concept of being a "minter" which will allow any particular address the permission to Mint tokens on the ',(0,i.kt)("inlineCode",{parentName:"p"},"contract_owner")," behalf and is a revokable permission."),(0,i.kt)("h2",{id:"types-of-non-fungible-contracts"},"Types of non fungible contracts"),(0,i.kt)("h3",{id:"zrc-1"},"ZRC-1"),(0,i.kt)("p",null,"The ZRC-1 contract can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/reference/zrc6.scilla"},"here")),(0,i.kt)("h4",{id:"zrc-1-interface"},"ZRC-1 interface"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* @dev:    Add or remove approved minters. Only contract_owner can approve minters. *)\n(* @param:  minter      - Address of the minter to be approved or removed            *)\ntransition ConfigureMinter(minter: ByStr20)\n\n(* @dev:    Mint new tokens. Only minters can mint.           *)\n(* @param:  to        - Address of the token recipient        *)\n(* @param:  token_uri - URI of the the new token to be minted *)\ntransition Mint(to: ByStr20, token_uri: String)\n\n(* @dev:    Mint multiple new tokens at once. Only minters can mint. *)\n(* @param:  to_list         - Addressses of the token recipient      *)\n(* @param:  token_uris_list - URIs of the the new token to be minted *)\ntransition BatchMint(to_list: List ByStr20, token_uris_list: List String)\n\n\n(* @dev:    Burn existing tokens. Only token_owner or an operator can burn a NFT. *)\n(* @param:  token_id - Unique ID of the NFT to be destroyed                       *)\ntransition Burn(token_id: Uint256)\n\n(* @dev: Approves OR remove an address ability to transfer a given token_id *)\n(* There can only be one approved_spender per token at any given time       *)\n(* param: to       - Address to be approved for the given token_id          *)\n(* param: token_id - Unique ID of the NFT to be approved                    *)\ntransition SetApprove(to: ByStr20, token_id: Uint256)\n\n(* @dev: Sets or unsets an operator for the _sender       *)\n(* @param: to - Address to be set or unset as an operator *)\ntransition SetApprovalForAll(to: ByStr20)\n\n(* @dev: Transfer the ownership of a given token_id to another address. token_owner only transition. *)\n(* @param: to       - Recipient address for the token                                                *)\n(* @param: token_id - Unique ID of the NFT to be transferred                                         *)\ntransition Transfer(to: ByStr20, token_id: Uint256)\n\n\n(* @dev: Transfer the ownership of a given token_id to another address. approved_spender or operator only transition. *)\n(* @param: to       - Recipient address for the NFT                                                                   *)\n(* @param: token_id - Unique ID of the NFT to be transferred                                                          *)\ntransition TransferFrom(to: ByStr20, token_id: Uint256)\n")),(0,i.kt)("h3",{id:"zrc-6"},"ZRC-6"),(0,i.kt)("p",null,"The ZRC-6 contract can be found ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/reference/zrc6.scilla"},"here"),"."),(0,i.kt)("h4",{id:"zrc-6-interface"},"ZRC-6 interface"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"procedure TransferToken(to: ByStr20, token_id: Uint256)\ntransition Pause()\ntransition Unpause()\ntransition SetRoyaltyRecipient(to: ByStr20)\ntransition SetRoyaltyFeeBPS(fee_bps: Uint128)\ntransition SetBaseURI(uri: String)\ntransition Mint(to: ByStr20)\ntransition BatchMint(to_list: List ByStr20)\ntransition Burn(token_id: Uint256)\ntransition BatchBurn(token_id_list: List Uint256)\ntransition AddMinter(minter: ByStr20)\ntransition RemoveMinter(minter: ByStr20)\ntransition SetSpender(spender: ByStr20, token_id: Uint256)\ntransition AddOperator(operator: ByStr20)\ntransition RemoveOperator(operator: ByStr20)\ntransition TransferFrom(to: ByStr20, token_id: Uint256)\ntransition BatchTransferFrom(to_token_id_pair_list: List (Pair ByStr20 Uint256))\ntransition SetContractOwnershipRecipient(to: ByStr20)\ntransition AcceptContractOwnership()\n")),(0,i.kt)("h2",{id:"transfering-nonfungible-tokens"},"Transfering Nonfungible Tokens"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'type TokenMove = | UserToContract | ContractToUser\n\nprocedure MoveNonFungibleTokenFromContractToUser(token_move: TokenMove, recipient_address: ByStr20, nonfungible: ByStr20, token_id: Uint256)\n  match token_move with\n    | ContractToUser =>\n      transfer_to_user = {\n        _tag: "TransferFrom";\n        _recipient: nonfungible;\n        _amount: uint128_zero;\n        to: recipient_address;\n        token_id: token_id\n        };\n      msgs = one_msg transfer_to_user;\n      send msgs;\n      e = {_eventname : "StoreMovedToUserSuccess"; nonfungible : nonfungible; token_id: token_id};  \n      event e\n      \n    | UserToContract =>\n    end\nend\n')),(0,i.kt)("h3",{id:"zrc-7"},"ZRC-7"),(0,i.kt)("h4",{id:"zrc-7-token_uri-example"},"ZRC-7 token_uri example"),(0,i.kt)("p",null,"Here's an example response, when querying a ZRC-6 non fungible contract for it's URI data, either at ",(0,i.kt)("inlineCode",{parentName:"p"},"base_uri/token_id")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"token_uri"),". The image is found as a URL on the JSON itself."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "name": "Creature #101",\n  "resource": "ipfs://QmZILGa7zXUbixvYJpgkRkaSCYEBtSwgVtfzkoD3YkNsE1",\n  "external_url": "https://example.com/creature",\n  "attributes": [\n    {\n      "trait_type": "Background",\n      "value": "Black"\n    },\n    {\n      "trait_type": "Eyes",\n      "value": "Big"\n    },\n    {\n      "trait_type": "Mouth",\n      "value": "Grin"\n    },\n    {\n      "display_type": "timestamp",\n      "trait_type": "Birthday",\n      "value": 1546360800\n    }\n  ]\n}\n')),(0,i.kt)("h4",{id:"zrc-7-external_url-example"},"ZRC-7 external_url example"),(0,i.kt)("p",null,"Projects can take advantage of the external_url field to store project specific infomation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'{\n  "name": "Unique and Diverse Creatures",\n  "description": "10,000 unique and diverse creatures living on the blockchain.",\n  "external_url": "https://example.com/creature",\n  "animation_url": "https://animation.example.com/creature"\n}\n')),(0,i.kt)("h2",{id:"further-reading"},"Further reading"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-1.md"},"ZRC-1")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-6.md"},"ZRC-6")),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-7.md"},"ZRC-7")))}d.isMDXComponent=!0}}]);