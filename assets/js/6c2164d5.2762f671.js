"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[7565],{3905:function(n,t,e){e.d(t,{Zo:function(){return u},kt:function(){return p}});var i=e(7294);function o(n,t,e){return t in n?Object.defineProperty(n,t,{value:e,enumerable:!0,configurable:!0,writable:!0}):n[t]=e,n}function r(n,t){var e=Object.keys(n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(n,t).enumerable}))),e.push.apply(e,i)}return e}function a(n){for(var t=1;t<arguments.length;t++){var e=null!=arguments[t]?arguments[t]:{};t%2?r(Object(e),!0).forEach((function(t){o(n,t,e[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)):r(Object(e)).forEach((function(t){Object.defineProperty(n,t,Object.getOwnPropertyDescriptor(e,t))}))}return n}function c(n,t){if(null==n)return{};var e,i,o=function(n,t){if(null==n)return{};var e,i,o={},r=Object.keys(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||(o[e]=n[e]);return o}(n,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);for(i=0;i<r.length;i++)e=r[i],t.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(n,e)&&(o[e]=n[e])}return o}var l=i.createContext({}),s=function(n){var t=i.useContext(l),e=t;return n&&(e="function"==typeof n?n(t):a(a({},t),n)),e},u=function(n){var t=s(n.components);return i.createElement(l.Provider,{value:t},n.children)},m={inlineCode:"code",wrapper:function(n){var t=n.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(n,t){var e=n.components,o=n.mdxType,r=n.originalType,l=n.parentName,u=c(n,["components","mdxType","originalType","parentName"]),d=s(e),p=o,f=d["".concat(l,".").concat(p)]||d[p]||m[p]||r;return e?i.createElement(f,a(a({ref:t},u),{},{components:e})):i.createElement(f,a({ref:t},u))}));function p(n,t){var e=arguments,o=t&&t.mdxType;if("string"==typeof n||o){var r=e.length,a=new Array(r);a[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=n,c.mdxType="string"==typeof n?n:o,a[1]=c;for(var s=2;s<r;s++)a[s]=e[s];return i.createElement.apply(null,a)}return i.createElement.apply(null,e)}d.displayName="MDXCreateElement"},4445:function(n,t,e){e.r(t),e.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return u},default:function(){return d}});var i=e(7462),o=e(3366),r=(e(7294),e(3905)),a=["components"],c={sidebar_position:3},l="Batch minting ZRC-6",s={unversionedId:"tutorials/interaction-tutorials/nft-collection/batchmint",id:"tutorials/interaction-tutorials/nft-collection/batchmint",isDocsHomePage:!1,title:"Batch minting ZRC-6",description:"Taking the example for HelloWorld Scilla transition interaction we can extend this to call our NFT contract to perform a Mint or BatchMint operation.",source:"@site/docs/tutorials/interaction-tutorials/nft-collection/batchmint.md",sourceDirName:"tutorials/interaction-tutorials/nft-collection",slug:"/tutorials/interaction-tutorials/nft-collection/batchmint",permalink:"/tutorials/interaction-tutorials/nft-collection/batchmint",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/tutorials/interaction-tutorials/nft-collection/batchmint.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Deploying a ZRC-6",permalink:"/tutorials/interaction-tutorials/nft-collection/deploy-contract"},next:{title:"Fetching ZRC-6 state",permalink:"/tutorials/interaction-tutorials/nft-collection/readstate"}},u=[{value:"Amendments made",id:"amendments-made",children:[]}],m={toc:u};function d(n){var t=n.components,e=(0,o.Z)(n,a);return(0,r.kt)("wrapper",(0,i.Z)({},m,e,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"batch-minting-zrc-6"},"Batch minting ZRC-6"),(0,r.kt)("p",null,"Taking the example for ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/Zilliqa-JavaScript-Library-Examples/blob/master/node/helloWorld.js"},"HelloWorld Scilla transition interaction")," we can extend this to call our NFT contract to perform a Mint or BatchMint operation."),(0,r.kt)("p",null,"As we stated previously, to first do any NFT operations. We firstly need to create a contract to house the data association."),(0,r.kt)("h2",{id:"amendments-made"},"Amendments made"),(0,r.kt)("p",null,"Instead of calling once, we take advantage of using the BatchMint operation whereby we can perform multiple mints in one transaction."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"multi_call")," is a pair of ByStr20 String which is the relationship of user address to token_uri - it's the parameters required for a singular mint. If base_uri is being used, then token_uri should be empty string. An array is filled up N times with this data."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"mintMsg")," is an object which is the accumulation of these ",(0,r.kt)("inlineCode",{parentName:"p"},"multi_call")," of the type ",(0,r.kt)("inlineCode",{parentName:"p"},"List (Pair ByStr20 String)"),". This type is required for the BatchMint operation."),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"BatchMint")," is a function which wraps the batch minting in a loop. The user specifies an amount of tokens to mint, and the function read's the current token_id present on the contract to determine how many more tokens should be minted, if any. We need to manually increase the nonce by once each time for the blockchain to understand the commands in order."),(0,r.kt)("p",null,"At this point it's a typical blockchain transaction. We post the data to the network, specifying a contract address, transition and parameter arguments. The chain will respond with a success or error response and that result is captured."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},'const { BN, Long, bytes, units } = require("@zilliqa-js/util");\nconst { Zilliqa } = require("@zilliqa-js/zilliqa");\nconst {\n  toBech32Address,\n  getAddressFromPrivateKey,\n} = require("@zilliqa-js/crypto");\n\nconst zilliqa = new Zilliqa("https://dev-api.zilliqa.com");\n\nconst chainId = 333; // chainId of the developer testnet\nconst msgVersion = 1; // current msgVersion\nconst VERSION = bytes.pack(chainId, msgVersion);\n\n// Populate the wallet with an account\nconst privateKey = "";\n\nzilliqa.wallet.addByPrivateKey(privateKey);\n\nconst zrc6contract = "18d1f737c1a1102cca966bf82dfe459e35fbd524";\n\nasync function IncrementingNonceBatchMint(nonce, n) {\n  try {\n    // Get Minimum Gas Price from blockchain\n    const minGasPrice = await zilliqa.blockchain.getMinimumGasPrice();\n\n    console.log(`Current Minimum Gas Price: ${minGasPrice.result}`);\n\n    const myGasPrice = units.toQa("6100", units.Units.Li); // Gas Price that will be used by all transactions\n\n    console.log(`My Gas Price ${myGasPrice.toString()}`);\n    const isGasSufficient = myGasPrice.gte(new BN(minGasPrice.result)); // Checks if your gas price is less than the minimum gas price\n    console.log(`Is the gas price sufficient? ${isGasSufficient}`);\n\n    const deployedContract = zilliqa.contracts.at(zrc6contract);\n\n    const user_address = "0x0000000000000000000000000000000000000000";\n\n    const multi_call = {\n      constructor: "Pair",\n      argtypes: ["ByStr20", "String"],\n      arguments: [user_address, ""],\n    };\n    const arrayOfPairs = Array(n).fill(multi_call);\n\n    const mintMsg = {\n      vname: "to_token_uri_pair_list",\n      type: "List (Pair ByStr20 String)",\n      value: arrayOfPairs,\n    };\n\n    const callTx = await deployedContract.callWithoutConfirm(\n      "BatchMint",\n      [mintMsg],\n      {\n        // amount, gasPrice and gasLimit must be explicitly provided\n        version: VERSION,\n        amount: new BN(0),\n        gasPrice: myGasPrice,\n        gasLimit: Long.fromNumber(61000),\n        nonce,\n      },\n      false\n    );\n\n    console.log(\n      `The transaction id is: https://viewblock.io/zilliqa/tx/0x${callTx.id}?network=testnet for ${n} mints`\n    );\n    console.log(`Waiting transaction be confirmed`);\n    const confirmedTxn = await callTx.confirm(callTx.id);\n\n    console.log(`The transaction status is:`);\n    console.log(confirmedTxn.receipt);\n\n    if (confirmedTxn.receipt.success === true) {\n      console.log(`Contract address is: ${deployedContract.address}`);\n    }\n  } catch (err) {\n    console.log(err);\n  }\n}\n\nasync function BatchMint() {\n  // Get Balance\n  const address = getAddressFromPrivateKey(privateKey);\n  console.log(`My account address is: ${address}`);\n  console.log(`My account bech32 address is: ${toBech32Address(address)}`);\n  const { result } = await zilliqa.blockchain.getBalance(address);\n  console.log(result);\n  let originalNonce;\n  if (result) {\n    originalNonce = result.nonce;\n  } else {\n    originalNonce = 0;\n  }\n\n  // ==============================================\n  const minted = (\n    await zilliqa.blockchain.getSmartContractSubState(\n      zrc6contract,\n      "total_supply"\n    )\n  )["result"]["total_supply"];\n\n  const maxToMint = 100;\n  const leftToMint = maxToMint - minted;\n  const numInBatch = 50;\n\n  console.log(leftToMint + " left to mint");\n  // ===============================================\n\n  let nonce = originalNonce;\n\n  const callsOfBatch = Math.floor(leftToMint / numInBatch);\n\n  console.log(`${callsOfBatch} callsOf ${numInBatch}`);\n  console.log(nonce);\n\n  for (let i = 1; i <= callsOfBatch; i++) {\n    console.log(`nonce: ${nonce + i}`);\n    IncrementingNonceBatchMint(nonce + i, numInBatch);\n  }\n\n  console.log(`nonce: ${nonce + callsOfBatch + 1}`);\n  IncrementingNonceBatchMint(nonce + callsOfBatch + 1, leftToMint % numInBatch);\n}\n\nBatchMint();\n')))}d.isMDXComponent=!0}}]);