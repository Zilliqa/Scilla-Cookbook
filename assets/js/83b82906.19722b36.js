"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[2302],{3905:function(n,e,t){t.d(e,{Zo:function(){return u},kt:function(){return p}});var r=t(7294);function o(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function c(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){o(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){if(null==n)return{};var t,r,o=function(n,e){if(null==n)return{};var t,r,o={},i=Object.keys(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||(o[t]=n[t]);return o}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(r=0;r<i.length;r++)t=i[r],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(o[t]=n[t])}return o}var s=r.createContext({}),l=function(n){var e=r.useContext(s),t=e;return n&&(t="function"==typeof n?n(e):c(c({},e),n)),t},u=function(n){var e=l(n.components);return r.createElement(s.Provider,{value:e},n.children)},d={inlineCode:"code",wrapper:function(n){var e=n.children;return r.createElement(r.Fragment,{},e)}},m=r.forwardRef((function(n,e){var t=n.components,o=n.mdxType,i=n.originalType,s=n.parentName,u=a(n,["components","mdxType","originalType","parentName"]),m=l(t),p=o,y=m["".concat(s,".").concat(p)]||m[p]||d[p]||i;return t?r.createElement(y,c(c({ref:e},u),{},{components:t})):r.createElement(y,c({ref:e},u))}));function p(n,e){var t=arguments,o=e&&e.mdxType;if("string"==typeof n||o){var i=t.length,c=new Array(i);c[0]=m;var a={};for(var s in e)hasOwnProperty.call(e,s)&&(a[s]=e[s]);a.originalType=n,a.mdxType="string"==typeof n?n:o,c[1]=a;for(var l=2;l<i;l++)c[l]=t[l];return r.createElement.apply(null,c)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},5101:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return a},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return u},default:function(){return m}});var r=t(7462),o=t(3366),i=(t(7294),t(3905)),c=["components"],a={sidebar_position:5},s="Summary",l={unversionedId:"tutorials/interaction-tutorials/incrementing-button-interaction/summary",id:"tutorials/interaction-tutorials/incrementing-button-interaction/summary",isDocsHomePage:!1,title:"Summary",description:"We've met all the objectives set out in 300 lines of easy to read and understand Javascript and now have a form of primitive automation.",source:"@site/docs/tutorials/interaction-tutorials/incrementing-button-interaction/summary.md",sourceDirName:"tutorials/interaction-tutorials/incrementing-button-interaction",slug:"/tutorials/interaction-tutorials/incrementing-button-interaction/summary",permalink:"/tutorials/interaction-tutorials/incrementing-button-interaction/summary",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/tutorials/interaction-tutorials/incrementing-button-interaction/summary.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"contract State",permalink:"/tutorials/interaction-tutorials/incrementing-button-interaction/fetch-state"},next:{title:"Introduction",permalink:"/tutorials/interaction-tutorials/nft-collection/introduction"}},u=[],d={toc:u};function m(n){var e=n.components,t=(0,o.Z)(n,c);return(0,i.kt)("wrapper",(0,r.Z)({},d,t,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"summary"},"Summary"),(0,i.kt)("p",null,"We've met all the objectives set out in 300 lines of easy to read and understand Javascript and now have a form of primitive automation."),(0,i.kt)("ul",{className:"contains-task-list"},(0,i.kt)("li",{parentName:"ul",className:"task-list-item"},(0,i.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","Use zilliqa-js to deploy a contract."),(0,i.kt)("li",{parentName:"ul",className:"task-list-item"},(0,i.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","Use zilliqa-js to interact with and press the button."),(0,i.kt)("li",{parentName:"ul",className:"task-list-item"},(0,i.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","Use zilliqa-js to get the mutable state of our contract."),(0,i.kt)("li",{parentName:"ul",className:"task-list-item"},(0,i.kt)("input",{parentName:"li",type:"checkbox",checked:!0,disabled:!0})," ","Use zilliqa-js to listen for events in our contract.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const { BN, Long, bytes, units } = require('@zilliqa-js/util');\nconst { Zilliqa } = require('@zilliqa-js/zilliqa');\nconst { StatusType, MessageType } = require('@zilliqa-js/subscriptions');\nconst { fromBech32Address, toBech32Address, getAddressFromPrivateKey} = require('@zilliqa-js/crypto');\n\n// these values can change depending on what network you are connecting on\nconst zilliqa = new Zilliqa('https://dev-api.zilliqa.com');\n// webhook to listen to events emited back to clients\nconst websocket = \"wss://dev-ws.zilliqa.com\"\nconst chainId = 333;\nconst msgVersion = 1; \nconst VERSION = bytes.pack(chainId, msgVersion);\n\n// use a dotenv file for storing private keys, do not commit this directly to your repo\nconst privateKey ='';\n// mutable state field name to monitor\nconst state_field_to_monitor = \"total_count_clicks\"\n\nzilliqa.wallet.addByPrivateKey(privateKey);\nconst address_from_pk = getAddressFromPrivateKey(privateKey);\n\n// Application Definition\n// DEPLOY a contract, \n// SEND a transaction\n// LISTEN to events emitted\n// MONITOR mutable state \nasync function DeploySendListenMonitor()\n{\n    deployed_contract_base_16 = await DeployButtonContract();\n    bech_32_bystr = toBech32Address(deployed_contract_base_16);\n    console.log(`got ${bech_32_bystr} from ${deployed_contract_base_16}`)\n\n    await Promise.all([\n        ListenForEvents(deployed_contract_base_16),\n        PressTheButton(bech_32_bystr)\n    ]);\n}\n\n// Runs Application\nDeploySendListenMonitor();\n\n// Deploys a contract using a private key, returns the deployed_contract_base_16 of the contract deployed\nasync function DeployButtonContract() {\n    try {\n      // Get Balance\n      const balance = await zilliqa.blockchain.getBalance(address_from_pk);\n      // Get Minimum Gas Price from blockchain\n      const minGasPrice = await zilliqa.blockchain.getMinimumGasPrice();\n  \n      // Account balance (See note 1)\n      console.log(`Your account balance is:`);\n      console.log(balance.result);\n      console.log(`Current Minimum Gas Price: ${minGasPrice.result}`);\n      const myGasPrice = units.toQa('2000', units.Units.Li); // Gas Price that will be used by all transactions\n      console.log(`My Gas Price ${myGasPrice.toString()}`);\n      const isGasSufficient = myGasPrice.gte(new BN(minGasPrice.result)); // Checks if your gas price is less than the minimum gas price\n      console.log(`Is the gas price sufficient? ${isGasSufficient}`);\n  \n      // Deploy a contract\n      console.log(`Deploying a new contract....`);\n      const code = `\nscilla_version 0\nlibrary MyFirstButton\n\nlet uint128_zero = Uint128 0\nlet uint128_one  = Uint128 1\nlet empty_bystr = 0x1111111111111111111111111111111111111111\n\n(* Error exception *)\ntype Error =\n| NotContractOwner\n| NotUniqueClicker\n\nlet make_error =\nfun (result : Error) =>\n    let result_code = \n    match result with\n    | NotContractOwner             => Int32 -1\n    | NotUniqueClicker             => Int32 -2\n    end\n    in\n    { _exception : \"Error\"; code : result_code }  \n    \n(*\n* Create a scilla contract which models a button that can be pressed by anyone. \n* If you are the recent button presser you may not press the button again.\n* When the button is pressed: Increment a counter and set the caller of the button press to be the most recent address.  \n* The owner of the button has the ability to reset the counter to zero \n*)\ncontract MyFirstButton\n(\ncontract_owner: ByStr20\n)\n\nfield current_clicker    : ByStr20 = empty_bystr\nfield total_count_clicks : Uint128 = uint128_zero\n\n(* \n@Dev: Emit Errors \n*)\nprocedure ThrowError(err : Error)\ne = make_error err;\nthrow e\nend\n\n(*\n@Dev : Throws an error if '_sender' is not 'contract_owner'\n*)\nprocedure IsContractOwner()\nis_contract_owner = builtin eq contract_owner _sender;\nmatch is_contract_owner with\n| True => \n    (* No Operation - Continue contract execution *)\n| False =>\n    err = NotContractOwner;\n    ThrowError err\nend\nend\n\n(*  \nDev: Increments 'current_clicker' by 'uint128_one'\n*)\nprocedure IncrementCounter()\nprevious_click_count <- total_count_clicks;\nnew_click_count = builtin add previous_click_count uint128_one;\ntotal_count_clicks := new_click_count;\n\ne = {_eventname : \"IncrementCounterSuccess\"; pcc:previous_click_count; ncc: new_click_count  };\nevent e\nend \n\n\n(*  \nDev: Throws an error if the current '_sender' is the previous 'current_clicker'\n*)\nprocedure IsPreviousClicker(new_clicker: ByStr20)\nprevious_clicker <- current_clicker;\nis_previous_clicker = builtin eq previous_clicker _sender;\nmatch is_previous_clicker with\n| True => \n    err = NotUniqueClicker;\n    ThrowError err\n| False =>\n    (* No Operation - Continue contract execution *)\nend\nend\n\n(*  \nDev: Sets 'new_clicker' as 'current_clicker'\n*)\nprocedure SetNewClicker(new_clicker: ByStr20)\ncurrent_clicker := new_clicker;\n\ne = {_eventname : \"NewClickerState\"; nc:new_clicker};\nevent e\nend\n\n(*  \nDev: Resets 'current_clicker' to 'uint128_zero'\n*)\nprocedure ContractOwnerResetButton()\ntotal_count_clicks  := uint128_zero\nend\n\n(*  \nDev: Sets 'new_clicker' as current_clicker\n*)\ntransition PressTheButton()\nIsPreviousClicker _sender;\nSetNewClicker _sender;\nIncrementCounter;\n\ne = {_eventname : \"PressTheButtonSuccess\"; button_presser : _sender };\nevent e\nend\n\n(*  \nDev: Sets 'new_clicker' as current_clicker\n*)\ntransition OwnerResetButton()\nIsContractOwner;\nContractOwnerResetButton\nend\n`;\n  \n      const init = [\n        // this parameter is mandatory for all init arrays\n        {\n          vname: '_scilla_version',\n          type: 'Uint32',\n          value: '0',\n        },\n        {\n          vname: 'contract_owner',\n          type: 'ByStr20',\n          value: `${address_from_pk}`,\n        },\n      ];\n  \n      const contract = zilliqa.contracts.new(code, init);\n  \n      // Deploy the contract.\n      // Also notice here we have a default function parameter named toDs as mentioned above.\n      // A contract can be deployed at either the shard or at the DS. Always set this value to false.\n      const [deployTx, deployedContract] = await contract.deployWithoutConfirm(\n        {\n          version: VERSION,\n          gasPrice: myGasPrice,\n          gasLimit: Long.fromNumber(10000),\n        },\n        false,\n      );\n  \n      // process confirm\n      console.log(`The transaction id is:`, deployTx.id);\n      console.log(`Waiting transaction be confirmed`);\n      const confirmedTxn = await deployTx.confirm(deployTx.id);\n  \n      console.log(`The transaction status is:`);\n      console.log(confirmedTxn.receipt);\n      if (confirmedTxn.receipt.success === true) {\n        console.log(`Contract address is: 0x${deployedContract.address}`);\n        return \"0x\" + deployedContract.address;\n      }\n    } catch (err) {\n      console.log(err);\n    }\n}\n\n// Listen for events from a contract - errors aren't caught\nasync function ListenForEvents(deployed_contract_base_16) \n{\n    const subscriber = zilliqa.subscriptionBuilder.buildEventLogSubscriptions(\n      websocket,\n      {\n        addresses: [\n            deployed_contract_base_16\n        ],\n      },\n    );\n\n    console.log(\"Listener started\");\n  \n    subscriber.emitter.on(MessageType.EVENT_LOG, async (event) => {\n        console.log('get new event log: ', JSON.stringify(event)); // this will emit 2/3 times before event emitted\n\n        const current_button_click_count = await zilliqa.blockchain.getSmartContractSubState(\n            deployed_contract_base_16,\n            state_field_to_monitor\n          );\n        console.log(current_button_click_count.result);\n        console.log(\"\")\n    });\n  \n    await subscriber.start();\n}\n\n// Calls the previously deployed contract transition\nasync function PressTheButton(bech_32_bystr) {\n  try {\n    const balance = await zilliqa.blockchain.getBalance(address_from_pk);\n    const minGasPrice = await zilliqa.blockchain.getMinimumGasPrice();\n    const myGasPrice = units.toQa('2000', units.Units.Li); \n    const isGasSufficient = myGasPrice.gte(new BN(minGasPrice.result)); \n    const deployedContract = zilliqa.contracts.at(bech_32_bystr,);\n\n    console.log(`Pressing the button...`);\n    const callTx = await deployedContract.callWithoutConfirm(\n        'PressTheButton', // transition name\n        [], // no vnames\n        {\n        version: VERSION,\n        amount: new BN(0), \n        gasPrice: myGasPrice, \n        gasLimit: Long.fromNumber(8000), \n        },\n        false,\n    );\n\n    console.log(`Waiting transaction be confirmed`);\n    const confirmedTxn = await callTx.confirm(callTx.id);\n\n    //console.log(`The transaction status is:`);\n    //console.log(confirmedTxn.receipt);\n    if (confirmedTxn.receipt.success === true) \n    {\n      console.log(`Button pressed by : ${address_from_pk}`);\n    }\n  } \n  catch (err) \n  {\n    console.log(err);\n  }\n}\n\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},'Your account balance is:\n{ balance: \'1990534999999850\', nonce: 307 }\nCurrent Minimum Gas Price: 2000000000\nMy Gas Price 2000000000\nIs the gas price sufficient? true\nDeploying a new contract....\nThe transaction id is: 1548964c7d852fdb5c2b606a62aba83a5e89ce3ec047c3eac8986b0943e10da7\nWaiting transaction be confirmed\nThe transaction status is:\n{ cumulative_gas: 401, epoch_num: \'3726858\', success: true }\nContract address is: 0x60d5edfe4bcff11bde238c153853bcf358654b41\ngot zil1vr27mljtelc3hh3r3s2ns5au7dvx2j6pa6p9k0 from 0x60d5edfe4bcff11bde238c153853bcf358654b41\nListener started\nPressing the button...\nWaiting transaction be confirmed\n\nget new event log:  {"query":"EventLog"}\n{ total_count_clicks: \'0\' }\n\nget new event log:  {"query":"EventLog","value":[{"address":"60d5edfe4bcff11bde238c153853bcf358654b41","event_logs":[{"_eventname":"PressTheButtonSuccess","params":[{"type":"ByStr20","value":"0x428a2aa43456fe7fd2de66e48c1fbf372ec10eae","vname":"button_presser"}]},{"_eventname":"IncrementCounterSuccess","params":[{"type":"Uint128","value":"0","vname":"pcc"},{"type":"Uint128","value":"1","vname":"ncc"}]},{"_eventname":"NewClickerState","params":[{"type":"ByStr20","value":"0x428a2aa43456fe7fd2de66e48c1fbf372ec10eae","vname":"nc"}]}]}]}\n{ total_count_clicks: \'1\' }\n\nButton pressed by : 0x428A2aA43456FE7fd2De66E48C1fBf372eC10eAE\nget new event log:  {"query":"EventLog"}\n{ total_count_clicks: \'1\' }\n')))}m.isMDXComponent=!0}}]);