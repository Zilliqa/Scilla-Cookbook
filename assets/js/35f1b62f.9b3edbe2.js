"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4023],{3905:function(t,e,a){a.d(e,{Zo:function(){return p},kt:function(){return d}});var n=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function o(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?o(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function s(t,e){if(null==t)return{};var a,n,r=function(t,e){if(null==t)return{};var a,n,r={},o=Object.keys(t);for(n=0;n<o.length;n++)a=o[n],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(n=0;n<o.length;n++)a=o[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var c=n.createContext({}),l=function(t){var e=n.useContext(c),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},p=function(t){var e=l(t.components);return n.createElement(c.Provider,{value:e},t.children)},u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},h=n.forwardRef((function(t,e){var a=t.components,r=t.mdxType,o=t.originalType,c=t.parentName,p=s(t,["components","mdxType","originalType","parentName"]),h=l(a),d=r,m=h["".concat(c,".").concat(d)]||h[d]||u[d]||o;return a?n.createElement(m,i(i({ref:e},p),{},{components:a})):n.createElement(m,i({ref:e},p))}));function d(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var o=a.length,i=new Array(o);i[0]=h;var s={};for(var c in e)hasOwnProperty.call(e,c)&&(s[c]=e[c]);s.originalType=t,s.mdxType="string"==typeof t?t:r,i[1]=s;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},749:function(t,e,a){a.r(e),a.d(e,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return h}});var n=a(7462),r=a(3366),o=(a(7294),a(3905)),i=["components"],s={tags:["metatransaction","reference","contract","zrc-3"]},c="Metatransactions",l={unversionedId:"recipes/scilla-contract/metatransactions",id:"recipes/scilla-contract/metatransactions",isDocsHomePage:!1,title:"Metatransactions",description:"What is a metatransaction?",source:"@site/docs/recipes/scilla-contract/metatransactions.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/metatransactions",permalink:"/Scilla-Cookbook/recipes/scilla-contract/metatransactions",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/docs/recipes/scilla-contract/metatransactions.md",tags:[{label:"metatransaction",permalink:"/Scilla-Cookbook/tags/metatransaction"},{label:"reference",permalink:"/Scilla-Cookbook/tags/reference"},{label:"contract",permalink:"/Scilla-Cookbook/tags/contract"},{label:"zrc-3",permalink:"/Scilla-Cookbook/tags/zrc-3"}],version:"current",frontMatter:{tags:["metatransaction","reference","contract","zrc-3"]},sidebar:"tutorialSidebar",previous:{title:"Messages, Callbacks & Contract-to-Contract Interaction",permalink:"/Scilla-Cookbook/recipes/scilla-contract/messages"},next:{title:"Muti-signature contracts",permalink:"/Scilla-Cookbook/recipes/scilla-contract/mutisignature"}},p=[{value:"What is a metatransaction?",id:"what-is-a-metatransaction",children:[]},{value:"How does it work?",id:"how-does-it-work",children:[]},{value:"Docker Interaction",id:"docker-interaction",children:[{value:"Relayer responsibilities",id:"relayer-responsibilities",children:[]}]},{value:"Further Reading",id:"further-reading",children:[]}],u={toc:p};function h(t){var e=t.components,a=(0,r.Z)(t,i);return(0,o.kt)("wrapper",(0,n.Z)({},u,a,{components:e,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"metatransactions"},"Metatransactions"),(0,o.kt)("h2",{id:"what-is-a-metatransaction"},"What is a metatransaction?"),(0,o.kt)("p",null,"Meta Transactions are a broad concept borrowed from Ethereum where it is typically used to load authenticated data onto a smart contract. This pattern is needed for many Ethereum projects including the \u2018gasless\u2019 relay system whereby one or more nodes accept transactions signed with a hidden private key and then wrap that transaction in a Ethereum transaction."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-3.md"},"ZRC-3")," defines the technical specification that another contract with the ability to perform transitions with metatransactions should consume."),(0,o.kt)("h2",{id:"how-does-it-work"},"How does it work?"),(0,o.kt)("p",null,"It\u2019s equivalent to adding a checkbook to your bank account (contract). Through the metatransaction which is defined by all the variables to show proof that the owner of the funds did authorize this exact spend in the form of a cryptographic signature of the entire message hash."),(0,o.kt)("p",null,"Metatransactions provide an alternative flow for users just getting started with their cryptocurrency and wallets. It allows for gasless transactions, cutting out the barrier of getting ZIL from an exchange or via mining before a Dapp user can interact with the smart contract."),(0,o.kt)("p",null,"It can also be seen as a way to defer the processing of transactions or even to guard a transition that requires multiparty authorization, although those applications are left to implementations and future standards."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/reference/MetaFungibleToken.scilla"},"The ZRC-3 contract")," adds a metatransfer transition to the existing ZRC-2 interface."),(0,o.kt)("h2",{id:"docker-interaction"},"Docker Interaction"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/starling-foundries/relay.js"},"relay.js")," is a repository containing the cheque relay to forward metatransactions to zilliqa network (sometimes called a bouncer proxy)."),(0,o.kt)("p",null,"This contract is based largely on the recommendations of EIP-965. It accomplishes similar goals, but also adds a functionality for gasless metatransactions. In this implementation the cheque is a message containing these parameters:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-JS"},'{\n         "from" : "0xa0000000...",\n           "to" : "0xb0000000...",\n       "amount" : 100,\n     "contract" : "0x12395345...",\n          "fee" : 2,\n        "nonce" : 12,\n    "signature" : "0xasdlj3io2j...",\n    "pubkey"    : "asdfg123..." \n}\n')),(0,o.kt)("p",null,"Note that the recipient, amount, contract, fee and nonce values are hashed and signed client-side before submitting the metatransaction to an arbitrary relay which can use this metatransaction as a spend-by-proxy. Both the relay and sender can be confident that parameters are properly validated on-chain, only a valid metatransaction can be spent and it can only be spent once."),(0,o.kt)("p",null,"This spend function does not replace the normal Transfer transition or the OperatorSend functionality already possible with ZRC2, instead it offers a third method for authorizing these transfers. One in which the holder of a token with spending authority is not presumed to have the Zil onhand to pay for transactions. It also optionally allows for paying transaction fees in tokens."),(0,o.kt)("p",null,"Posession of a metatransaction authorizes a relayer to submit this cheque on their behalf. This does not guarantee the funds, as any other transactions spending funds will be ordered like any other within the blockchain. This is by design as it removes the main way relays can abuse power - by censoring transactions."),(0,o.kt)("p",null,"If a relayer does not submit the cheque in a timely manner, the token holder has the opportunity to send the same metatransaction to the voidcheque transition to ensure the stalled transaction is not processed later."),(0,o.kt)("h3",{id:"relayer-responsibilities"},"Relayer responsibilities"),(0,o.kt)("p",null,"The relayer provides a public endpoint for recieving metatransactions, chequeing it's target contract and can validate any parameters to avoid wasting its own gas with a transaction that might be refused due to balance or previous spending of the metatransaction."),(0,o.kt)("p",null,"It may optionally report a minimum fee, but it cannot charge a fee that the token owner did not approve in the signed metatransaction. The anticipated malevolent behavior - a relayer censoring transactions - is mitigated by the possibility for multiple relayers."),(0,o.kt)("h2",{id:"further-reading"},"Further Reading"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://medium.com/builders-of-zilliqa/zrc3s-grand-rewrite-22558797ea0"},"Medium - ZRC3\u2019s Grand Rewrite")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-3.md"},"ZRC-3 Specification")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/reference/MetaFungibleToken.scilla"},"ZRC-3 - Contract")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/tree/master/example/zrc3"},"ZRC3 - Interaction")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/starling-foundries/relay.js"},'relay.js "bouncer proxy" - Docker Interaction')))}h.isMDXComponent=!0}}]);