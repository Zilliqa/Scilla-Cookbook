"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[215],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return y}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),s=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),d=s(n),y=o,m=d["".concat(l,".").concat(y)]||d[y]||u[y]||a;return n?r.createElement(m,i(i({ref:t},p),{},{components:n})):r.createElement(m,i({ref:t},p))}));function y(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=d;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:o,i[1]=c;for(var s=2;s<a;s++)i[s]=n[s];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},5660:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return l},metadata:function(){return s},toc:function(){return p},default:function(){return d}});var r=n(7462),o=n(3366),a=(n(7294),n(3905)),i=["components"],c={tags:["proxy","pattern"]},l="Pattern (proxy)",s={unversionedId:"recipes/scilla-recipes/pattern_proxy",id:"recipes/scilla-recipes/pattern_proxy",isDocsHomePage:!1,title:"Pattern (proxy)",description:"Proxy patterns allows developers to adapt to a changing environment and to react to bugs and other errors. To overcome the limitations introduced by the immutability of contract code, a contract can be split up into modules, which are then virtually upgradeable.",source:"@site/docs/recipes/scilla-recipes/pattern_proxy.md",sourceDirName:"recipes/scilla-recipes",slug:"/recipes/scilla-recipes/pattern_proxy",permalink:"/recipes/scilla-recipes/pattern_proxy",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-recipes/pattern_proxy.md",tags:[{label:"proxy",permalink:"/tags/proxy"},{label:"pattern",permalink:"/tags/pattern"}],version:"current",frontMatter:{tags:["proxy","pattern"]},sidebar:"tutorialSidebar",previous:{title:"Pattern (pause)",permalink:"/recipes/scilla-recipes/pattern_pause"},next:{title:"Pattern (push vs pull)",permalink:"/recipes/scilla-recipes/pattern_pushvspush"}},p=[{value:"Further reading",id:"further-reading",children:[]}],u={toc:p};function d(e){var t=e.components,c=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,r.Z)({},u,c,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pattern-proxy"},"Pattern (proxy)"),(0,a.kt)("p",null,"Proxy patterns allows developers to adapt to a changing environment and to react to bugs and other errors. To overcome the limitations introduced by the immutability of contract code, a contract can be split up into modules, which are then virtually upgradeable."),(0,a.kt)("p",null,"They are only virtually upgradeable, because existing contracts still cannot be changed. However, a new version of the contract can be deployed and its address replaces the old one in storage. To avoid breaking dependencies of other contracts that are referencing the upgraded contract, or users who do not know about the release of a new contract version (that comes with a new address), we make use of a proxy contract that delegates calls to the specific modules"),(0,a.kt)("p",null,"The proxy pattern is easily understood with an example of minting NFTs. An NFT contract requires an 'Minter' to handle the responsibility of being the trusted entity to Mint. In a dapp, if the caller tried to call Mint, they would be returned a 'NotMinter' error. We can get around this by creating a new contract which will be the 'Minter' and will contain logic about what conditions to mint an NFT."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"Docusaurus",src:n(5460).Z})),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* configured with 'NFT_Proxy' as a minter before calls are made *)\ncontract NonfungibleToken()\n\nprocedure MintToken(to: ByStr20)\n  IsMinter _sender;\n  ...\nend\n\ntransition AddMinter(to: ByStr20)\n...\nend\n\n(* if anyone BUT the minter calls this transition an error is thrown *)\ntransition Mint(to: ByStr20)\n  MintToken to;\n  ...\nend\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"(* allows anyone to call ProxyBuy, when sending to NonfungibleToken the _sender 'NFT_Proxy' will be a minter *)\ncontract NFT_Proxy()\n\nprocedure ProxyCallMint(to: ByStr20)\n  IsMinter _sender;\n    e = {};\n  ...\nend\n\n(* _sender calls this function *)\ntransition ProxyBuy()\n  (* is _amount the quantity we are expecting? *)\n  ProxyCallMint;\n  ...\nend\n")),(0,a.kt)("p",null,"Consider if we wanted to deploy some new proxy logic to effect our NFT minting, we could easily deploy a new contract and upgrade the NonFungibleToken delegated Minter to point at our new proxy. We have managed to upgrade some immutable logic by using the proxy pattern."),(0,a.kt)("h2",{id:"further-reading"},"Further reading"))}d.isMDXComponent=!0},5460:function(e,t,n){t.Z=n.p+"assets/images/proxy-diagram-b624523430d0ea6768976481e8e6deea.png"}}]);