"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4384],{3905:function(e,t,r){r.d(t,{Zo:function(){return p},kt:function(){return d}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},p=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),h=l(r),d=a,f=h["".concat(c,".").concat(d)]||h[d]||u[d]||o;return r?n.createElement(f,s(s({ref:t},p),{},{components:r})):n.createElement(f,s({ref:t},p))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},6804:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return h}});var n=r(7462),a=r(3366),o=(r(7294),r(3905)),s=["components"],i={tags:["proxy","push","pull","merkel tree"]},c="Pattern (push vs pull)",l={unversionedId:"recipes/scilla-recipes/pattern_pushvspush",id:"recipes/scilla-recipes/pattern_pushvspush",isDocsHomePage:!1,title:"Pattern (push vs pull)",description:"Let's consider the scenario where we have some funds in a contract or a wallet and we are trying to distribute these to multiple addresses. You could choose to send these manually, one-by-one or you could choose to automate batch sending these. In either case the token owner is sending `n` transactions to addresses.",source:"@site/docs/recipes/scilla-recipes/pattern_pushvspush.md",sourceDirName:"recipes/scilla-recipes",slug:"/recipes/scilla-recipes/pattern_pushvspush",permalink:"/recipes/scilla-recipes/pattern_pushvspush",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-recipes/pattern_pushvspush.md",tags:[{label:"proxy",permalink:"/tags/proxy"},{label:"push",permalink:"/tags/push"},{label:"pull",permalink:"/tags/pull"},{label:"merkel tree",permalink:"/tags/merkel-tree"}],version:"current",frontMatter:{tags:["proxy","push","pull","merkel tree"]},sidebar:"tutorialSidebar",previous:{title:"Pattern (proxy)",permalink:"/recipes/scilla-recipes/pattern_proxy"},next:{title:"Pattern (viewer)",permalink:"/recipes/scilla-recipes/pattern_view"}},p=[{value:"Further reading",id:"further-reading",children:[]}],u={toc:p};function h(e){var t=e.components,i=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"pattern-push-vs-pull"},"Pattern (push vs pull)"),(0,o.kt)("p",null,"Let's consider the scenario where we have some funds in a contract or a wallet and we are trying to distribute these to multiple addresses. You could choose to send these manually, one-by-one or you could choose to automate batch sending these. In either case the token owner is sending ",(0,o.kt)("inlineCode",{parentName:"p"},"n")," transactions to addresses."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Docusaurus",src:r(6333).Z})),(0,o.kt)("p",null,"Compare this to the Pull model. First, the entity responsible for the initiation of the transfer (e.g. the owner of a contract, or the contract itself) starts the process. Secondly, the smart contract has the responsibility of keeping track of all balances. The third participant is the receiver, who will not simply receive his funds via a transaction, but has to actively request a withdrawal, in order to isolate the process from other payout and contract logic."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Docusaurus",src:r(7474).Z})),(0,o.kt)("p",null,"Compartively the responsibility has switched from the contract owner to send directly to many addresses - to the contract owner sending a batch transaction to the contract containing all the accounts and their associated rewards. Users can now claim these directly from the contract."),(0,o.kt)("p",null,"So we've moved from pushing transactions to users, to sending one transaction to a smart contract that allows the specific user to pull an amount from. How would we improve this further?"),(0,o.kt)("p",null,"A Merkel Tree is a data structure that takes a set of data. In our case this is a tuple of account and amount, and will hash each node with another to from a resulting node (as this is a tree, two nodes can be related to a parent) - those result nodes are hashed together also, until one master (root) result hash is present at the top of the tree. For a given user address at the bottom of the structure, you only need to know a certain amount of 'proof' nodes to calculate the master (root) hash."),(0,o.kt)("p",null,"Given that you have the data and can present an API to a user which for a given address and an epoch period can firstly tell you if you was present, and secondly generate a set of proofs for that address - a Merkel tree contract can be created. The developer would send 1 transaction with the master (root) to the contract instead of N - which is a vast improvement! The user sends the proofs to the contract which validates they are present and the proof plus their node equally matched the root hash."),(0,o.kt)("h2",{id:"further-reading"},"Further reading"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://medium.com/builders-of-zilliqa/token-distributors-in-scilla-b37241f7466a"},"Token distributors in Scilla")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://medium.com/builders-of-zilliqa/merkle-tree-and-proofs-for-distributor-e9c54f737e9"},"Merkle tree and proofs for distributor")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Switcheo/zap-api"},"ZAP-API")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Switcheo/zwap-token/tree/master/contracts"},"ZIL/Token distributor contract")))}h.isMDXComponent=!0},7474:function(e,t,r){t.Z=r.p+"assets/images/pull-diagram-bdd1126fcb1a0e060ed0ac500db14cf9.png"},6333:function(e,t,r){t.Z=r.p+"assets/images/push-diagram-2ffb1c4ae853586d07d10b0a0a1c9006.png"}}]);