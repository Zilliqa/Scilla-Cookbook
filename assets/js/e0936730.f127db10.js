"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[2969],{3905:function(t,e,n){n.d(e,{Zo:function(){return u},kt:function(){return d}});var i=n(7294);function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function s(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function o(t,e){if(null==t)return{};var n,i,l=function(t,e){if(null==t)return{};var n,i,l={},r=Object.keys(t);for(i=0;i<r.length;i++)n=r[i],e.indexOf(n)>=0||(l[n]=t[n]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(i=0;i<r.length;i++)n=r[i],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(l[n]=t[n])}return l}var a=i.createContext({}),c=function(t){var e=i.useContext(a),n=e;return t&&(n="function"==typeof t?t(e):s(s({},e),t)),n},u=function(t){var e=c(t.components);return i.createElement(a.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return i.createElement(i.Fragment,{},e)}},f=i.forwardRef((function(t,e){var n=t.components,l=t.mdxType,r=t.originalType,a=t.parentName,u=o(t,["components","mdxType","originalType","parentName"]),f=c(n),d=l,m=f["".concat(a,".").concat(d)]||f[d]||p[d]||r;return n?i.createElement(m,s(s({ref:e},u),{},{components:n})):i.createElement(m,s({ref:e},u))}));function d(t,e){var n=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=n.length,s=new Array(r);s[0]=f;var o={};for(var a in e)hasOwnProperty.call(e,a)&&(o[a]=e[a]);o.originalType=t,o.mdxType="string"==typeof t?t:l,s[1]=o;for(var c=2;c<r;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},5850:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return o},contentTitle:function(){return a},metadata:function(){return c},toc:function(){return u},default:function(){return f}});var i=n(7462),l=n(3366),r=(n(7294),n(3905)),s=["components"],o={tags:["List"]},a="List",c={unversionedId:"recipes/scilla-contract/list",id:"recipes/scilla-contract/list",isDocsHomePage:!1,title:"List",description:"A list is a data type which can hold several instances of a singular type.",source:"@site/docs/recipes/scilla-contract/list.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/list",permalink:"/Scilla-Cookbook/recipes/scilla-contract/list",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/docs/recipes/scilla-contract/list.md",tags:[{label:"List",permalink:"/Scilla-Cookbook/tags/list"}],version:"current",frontMatter:{tags:["List"]},sidebar:"tutorialSidebar",previous:{title:"Glossary of Keywords & Conventions",permalink:"/Scilla-Cookbook/recipes/scilla-contract/keywords"},next:{title:"Maps",permalink:"/Scilla-Cookbook/recipes/scilla-contract/map"}},u=[{value:"Example List Contract",id:"example-list-contract",children:[]},{value:"User Defined List Functions",id:"user-defined-list-functions",children:[{value:"listByStr20Contains",id:"listbystr20contains",children:[]},{value:"listByStr20Excludes",id:"listbystr20excludes",children:[]},{value:"listByStr20FilterOut",id:"listbystr20filterout",children:[]}]},{value:"Further Reading",id:"further-reading",children:[]}],p={toc:u};function f(t){var e=t.components,n=(0,l.Z)(t,s);return(0,r.kt)("wrapper",(0,i.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"list"},"List"),(0,r.kt)("p",null,"A list is a data type which can hold several instances of a singular type."),(0,r.kt)("p",null,"Consider the below definition of creating a List of Uint256."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'(* transition with Option argumen *)\ntransition OptionTest(option: Option Uint32)\n  ev = {_eventname: "OptionTest"; option: option };\n  event ev\nend\n')),(0,r.kt)("h2",{id:"example-list-contract"},"Example List Contract"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'scilla_version 0\n(***************************************************)\n(* List operations                                 *)\n(***************************************************)\nimport ListUtils BoolUtils\n\nlibrary List\n\nlet empty_list = Nil {Uint32}\n\nlet one   = Uint32 1 (* numbers 1, 2 and 3 to use below *)\nlet two   = Uint32 2\nlet three = Uint32 3\n\nlet create_3el_list = (* utility to create a list with 3 elements *)\n  fun (e1 : Uint32) =>\n  fun (e2 : Uint32) =>\n  fun (e3 : Uint32) =>\n  let nil = empty_list in\n      let le3 = Cons {Uint32} e3 empty_list in (* insert in front *)\n      let le2e3 = Cons {Uint32} e2 le3 in\n      Cons {Uint32} e1 le2e3 (* [e1, e2, e3] *)\n\nlet equal = fun (a: Uint32) => fun(b: Uint32) =>\n  builtin eq a b\n\nlet not_equal = fun (a: Uint32) => fun(b: Uint32) =>\n  let equal = builtin eq a b in\n  negb equal (* from BoolUtils *)\n\ncontract List()\n\nfield list : List Uint32 = empty_list\nfield doubles : Map Uint32 Uint32 = Emp Uint32 Uint32 (* doubles[l[i]]=2*l[i] *)\n\n(* create a list [1,2,3] and store in field list *)\ntransition Create123()\n  l = create_3el_list one two three; (* [1, 2, 3] *)\n  list := l\nend\n\n(* access n-th element of a list using list_nth, and emit it *)\ntransition ElementAtPosition(n: Uint32)\n  l <- list;\n  el_opt =\n    let nth = @list_nth Uint32 in (* from ListUtils *)\n    nth n l; (* note that indexing starts at 0 *)\n  match el_opt with (* Option is None if no element with index i in list *)\n  | None => (* index is out of bounds: no such element *)\n    ev = {_eventname: "ElementAtPositionFailure"};\n    event ev\n  | Some el => (* list[i] = el *)\n    ev = {_eventname: "ElementAtPositionSuccess"; index: n; element: el};\n    event ev\n  end\nend\n\n(* remove elements from list that equal to value *)\ntransition RemoveIfEqualtTo(value: Uint32)\n  f = not_equal value;\n  filterUint32 = @list_filter Uint32; (* from ListUtils *)\n  l <- list;\n  list_without_values = filterUint32 f l;\n  list := list_without_values\nend\n\n(* compare the lists [1,2,3] and [3 2 1] *)\ntransition Compare123To321()\n  l123 = create_3el_list one two three; (* [1, 2, 3] *)\n  l321 = create_3el_list three two one; (* [3, 2, 1] *)\n  list_zip_eq_with = @list_zip_with Uint32 Uint32 Bool; (* from ListUtils *)\n  r = list_zip_eq_with equal l123 l321;\n  ev = {_eventname : "Compare123To321"; result: r};\n  event ev\nend\n\n(* compute the element wise difference of 2 lists *)\ntransition Difference321Minus111()\n    l321 = create_3el_list three two one; (* [3, 2, 1] *)\n    l111 = create_3el_list one one one; (* [1, 1, 1] *)\n    list_zip_diff = @list_zip_with Uint32 Uint32 Uint32; (* from ListUtils *)\n    r = let diff = fun (a: Uint32) => fun(b: Uint32) => builtin sub a b in (* diff = a - b *)\n      list_zip_diff diff l321 l111;\n    ev = {_eventname: "Difference321Minus111"; result: r};\n    event ev\nend\n\n(* compute 2*l[i] and store in doubles[l[i]] *)\nprocedure Twice(v: Uint32)\n  res =\n    let two = Uint32 2 in (* res = 2 * v *)\n    builtin mul v two;\n  doubles[v] := res (* store in map *)\nend\ntransition ComputeDoubles()\n  l <- list;\n  forall l Twice (* apply Twice(.) to each element *)\nend\n\n(* sum the elements of a list using a left fold: res = 1 + 1 + 2 = 4 *)\ntransition SumElements112()\n  l = create_3el_list one one two; (* [1, 1, 2] *)\n  folder = @list_foldl Uint32 Uint32; (* accumulator and list elements are of type Uint32 *)\n  sum_of_elements =\n    let init = Uint32 0 in (* initialize the accumulator at 0 *)\n    let addition = (* add elements to accumulator: a + b *)\n      fun(a: Uint32) => fun(b: Uint32) =>\n        builtin add a b in\n    folder addition init l;\n  ev = {_eventname: "SumElements112"; sum: sum_of_elements};\n  event ev\nend\n')),(0,r.kt)("h2",{id:"user-defined-list-functions"},"User Defined List Functions"),(0,r.kt)("p",null,"The below snippets are user defined library snippets which involve the List type."),(0,r.kt)("h3",{id:"listbystr20contains"},"listByStr20Contains"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let listByStr20Contains =\n  fun(list: List ByStr20) =>\n  fun(bs: ByStr20) =>\n    let listMemByStr20 = @list_mem ByStr20 in\n      listMemByStr20 eqByStr20 bs list\n")),(0,r.kt)("h3",{id:"listbystr20excludes"},"listByStr20Excludes"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let listByStr20Excludes =\n  fun(list: List ByStr20) =>\n  fun(bs: ByStr20) =>\n    let b = listByStr20Contains list bs in negb b\n")),(0,r.kt)("h3",{id:"listbystr20filterout"},"listByStr20FilterOut"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let listByStr20FilterOut =\n  fun(list: List ByStr20) =>\n  fun(bs: ByStr20) =>\n    let listByStr20Filter = @list_filter ByStr20 in\n    let fn = fun(v: ByStr20) =>\n      let b = builtin eq v bs in\n       negb b in\n      listByStr20Filter fn list\n")),(0,r.kt)("h2",{id:"further-reading"},"Further Reading"))}f.isMDXComponent=!0}}]);