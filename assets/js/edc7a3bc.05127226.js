"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[1207],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var i=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var u=i.createContext({}),s=function(e){var n=i.useContext(u),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},c=function(e){var n=s(e.components);return i.createElement(u.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},m=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,u=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=s(t),d=r,f=m["".concat(u,".").concat(d)]||m[d]||p[d]||a;return t?i.createElement(f,o(o({ref:n},c),{},{components:t})):i.createElement(f,o({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,o=new Array(a);o[0]=m;var l={};for(var u in n)hasOwnProperty.call(n,u)&&(l[u]=n[u]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var s=2;s<a;s++)o[s]=t[s];return i.createElement.apply(null,o)}return i.createElement.apply(null,t)}m.displayName="MDXCreateElement"},3322:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return l},contentTitle:function(){return u},metadata:function(){return s},toc:function(){return c},default:function(){return m}});var i=t(7462),r=t(3366),a=(t(7294),t(3905)),o=["components"],l={tags:["folding","recursion","iterate"]},u="Functions",s={unversionedId:"recipes/scilla-recipes/functions",id:"recipes/scilla-recipes/functions",isDocsHomePage:!1,title:"Functions",description:"Functions in Scilla are abstracted a level away from Transitions and Procedures. Functions are available to be used by libraries and used in a forall statement as the function to be executed. Functions can also be used as helper methods in Transitions and Procedures.",source:"@site/docs/recipes/scilla-recipes/functions.md",sourceDirName:"recipes/scilla-recipes",slug:"/recipes/scilla-recipes/functions",permalink:"/Scilla-Cookbook-1/recipes/scilla-recipes/functions",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-recipes/functions.md",tags:[{label:"folding",permalink:"/Scilla-Cookbook-1/tags/folding"},{label:"recursion",permalink:"/Scilla-Cookbook-1/tags/recursion"},{label:"iterate",permalink:"/Scilla-Cookbook-1/tags/iterate"}],version:"current",frontMatter:{tags:["folding","recursion","iterate"]},sidebar:"tutorialSidebar",previous:{title:"Recursion",permalink:"/Scilla-Cookbook-1/recipes/scilla-recipes/folding"},next:{title:"Funds",permalink:"/Scilla-Cookbook-1/recipes/scilla-recipes/funds"}},c=[{value:"Common functions examples",id:"common-functions-examples",children:[{value:"blk_leq",id:"blk_leq",children:[]},{value:"muldiv",id:"muldiv",children:[]},{value:"uint128_to_uint256",id:"uint128_to_uint256",children:[]},{value:"uint128_difference",id:"uint128_difference",children:[]},{value:"eqByStr20",id:"eqbystr20",children:[]}]},{value:"build_pair",id:"build_pair",children:[]},{value:"(Generics) get_option_value",id:"generics-get_option_value",children:[]}],p={toc:c};function m(e){var n=e.components,t=(0,r.Z)(e,o);return(0,a.kt)("wrapper",(0,i.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"functions"},"Functions"),(0,a.kt)("p",null,"Functions in Scilla are abstracted a level away from Transitions and Procedures. Functions are available to be used by libraries and used in a forall statement as the function to be executed. Functions can also be used as helper methods in Transitions and Procedures."),(0,a.kt)("p",null,"Let's examine how a function is written and how it's returned."),(0,a.kt)("p",null,"The below function takes a singular argument of an Optional Uint128, the function has to return the same type, so in the case of no match (None), we will return Uint128 representation of zero, in the case where we have Some, we'll return the Uint128 representation of that value."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let get_val_from_maybe_uint128 =     (* Name of the function *)\n  fun (some_val: Option Uint128) =>  (* Argument, in this case an unwrapped Option *)\n  match some_val with                (* Scilla expression begins here *)\n  | Some val => val                  (* Unwraps value and returns *)\n  | None => uint128_zero             (* In the case of no match, return uint128 0, function return Some uint128 *)\n  end\n")),(0,a.kt)("p",null,"In our implementation, we can call on this function to unwrap any Option Uint128 without verbose Some/None pattern matching."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml",metastring:"{10}","{10}":!0},"let uint128_zero = Uint128 0\nlet user_map : Map ByStr20 Uint128 = Emp ByStr20 Uint128\n\n(* Map of ByStr20 Uint128 maps a user to a token *)\nprocedure ExampleFunctionCall() \n  (* get a Some/None Uint128 value*)\n  maybe_user_uint128_value <- user_map[recipient];    \n\n  (* return Uint128 If None return 0 *)\n  user_balance = get_val_from_maybe_uint128 maybe_user_uint128_value; \n  user_balance_is_zero = builtin eq user_balance uint128_zero\n\n  (* act *)\n  match user_balance_is_zero with\n    | True =>\n        (* user either has 0 balance OR wasn't present in the Map *)\n    | False =>\n  end\nend\n")),(0,a.kt)("h2",{id:"common-functions-examples"},"Common functions examples"),(0,a.kt)("h3",{id:"blk_leq"},"blk_leq"),(0,a.kt)("p",null,"blk_leq is a library function that takes two blocks. It defines two boolean variables ",(0,a.kt)("inlineCode",{parentName:"p"},"bc1")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"bc2"),".\nIf the first block is less than the second variable ",(0,a.kt)("inlineCode",{parentName:"p"},"bc1")," is set to true.\nIf the first block is equal to the second variable ",(0,a.kt)("inlineCode",{parentName:"p"},"bc2")," is set to true.\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"ORB")," builtin from the Bools.Util performs a logical OR operator, returning true if either ",(0,a.kt)("inlineCode",{parentName:"p"},"bc1")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"bc2")," are true."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let blk_leq =\n  fun (blk1 : BNum) =>\n  fun (blk2 : BNum) =>\n    let bc1 = builtin blt blk1 blk2 in \n    let bc2 = builtin eq blk1 blk2 in \n    orb bc1 bc2\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"transition Implementation(query_block: BNum, current_block: BNum)\n    less_or_equal_to_query = blk_leq query_block current_block;\nend\n")),(0,a.kt)("h3",{id:"muldiv"},"muldiv"),(0,a.kt)("p",null,"Given the amount of tokens a user has, the total of the pool, and the amount of rewards - returns users percentage of rewards compared to the rest of the pool."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},'(* Compute "(x * y) / z" with protection against integer overflows *)\nlet muldiv : Uint128 -> Uint128 -> Uint128 -> Uint128 =\n    fun (x : Uint128) =>\n    fun (y : Uint128) =>\n    fun (z : Uint128) =>\n      let x256 = uint128_to_uint256 x in\n      let y256 = uint128_to_uint256 y in\n      let z256 = uint128_to_uint256 z in\n      let x_mul_y256 = builtin mul x256 y256 in\n      let res256 = builtin div x_mul_y256 z256 in\n      let ores128 = builtin to_uint128 res256 in\n      match ores128 with\n      | None =>\n        (* this must never happen, hence we throw an integer overflow exception *)\n        let max_uint128 = Uint128 340282366920938463463374607431768211455 in\n        let fourtytwo128 = Uint128 42 in\n        builtin mul max_uint128 fourtytwo128\n      | Some res128 =>\n        res128\n      end\n')),(0,a.kt)("h3",{id:"uint128_to_uint256"},"uint128_to_uint256"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let uint128_to_uint256 : Uint128 -> Uint256 =\n  fun (x : Uint128) =>\n    let ox256 = builtin to_uint256 x in\n      match ox256 with\n      | None =>\n        (* this never happens, hence we throw a division by zero exception just in case *)\n        let zero = Uint256 0 in\n        builtin div zero zero\n      | Some x256 => x256\n      end\n")),(0,a.kt)("h3",{id:"uint128_difference"},"uint128_difference"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let uint128_difference =\n  fun (old: Uint128) =>\n  fun (new: Uint128) =>\n    let a = builtin lt old new in\n    match a with\n    | True =>\n      builtin sub new old\n    | False =>\n      builtin sub old new\n    end\n")),(0,a.kt)("h3",{id:"eqbystr20"},"eqByStr20"),(0,a.kt)("p",null,"Takes two addresses and returns a ",(0,a.kt)("inlineCode",{parentName:"p"},"Bool")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"builtin eq")," if the addresses are equal."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let eqByStr20 =\n  fun(bs1: ByStr20) =>\n  fun(bs2: ByStr20) =>\n    builtin eq bs1 bs2\n")),(0,a.kt)("h2",{id:"build_pair"},"build_pair"),(0,a.kt)("p",null,"Takes two arguments and constructs a Pair object from them."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let build_pair =\n  fun (input_to_address : ByStr20) =>\n  fun (input_token_uri : String) =>\n    Pair {ByStr20 String} input_to_address input_token_uri\n")),(0,a.kt)("h2",{id:"generics-get_option_value"},"(Generics) get_option_value"),(0,a.kt)("p",null,"Allows for any generic optional type to be unwrapped using ",(0,a.kt)("inlineCode",{parentName:"p"},"tfun 'A")," where ",(0,a.kt)("inlineCode",{parentName:"p"},"'A")," is some type."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ocaml"},"let get_option_value =\n  tfun 'A =>\n  fun (default: 'A) =>\n  fun (opt_val: Option 'A) =>\n    match opt_val with\n    | Some v => v\n    | None => default\n    end\n")))}m.isMDXComponent=!0}}]);