"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[1639],{3905:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function c(e,n){if(null==e)return{};var t,r,i=function(e,n){if(null==e)return{};var t,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var s=r.createContext({}),l=function(e){var n=r.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},u=function(e){var n=l(e.components);return r.createElement(s.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},f=r.forwardRef((function(e,n){var t=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),f=l(t),m=i,d=f["".concat(s,".").concat(m)]||f[m]||p[m]||o;return t?r.createElement(d,a(a({ref:n},u),{},{components:t})):r.createElement(d,a({ref:n},u))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var o=t.length,a=new Array(o);a[0]=f;var c={};for(var s in n)hasOwnProperty.call(n,s)&&(c[s]=n[s]);c.originalType=e,c.mdxType="string"==typeof e?e:i,a[1]=c;for(var l=2;l<o;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}f.displayName="MDXCreateElement"},8585:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return u},default:function(){return f}});var r=t(7462),i=t(3366),o=(t(7294),t(3905)),a=["components"],c={tags:["non","fungible","token","reference","contract","zrc-1"]},s="Non-fungible token",l={unversionedId:"recipes/scilla-recipes/nonfungible",id:"recipes/scilla-recipes/nonfungible",isDocsHomePage:!1,title:"Non-fungible token",description:"A fungible token is unit of currency that can be readily interchanged, it has properties like fiat where 1 unit of currency is equal to 1 unit of the same currency.",source:"@site/docs/recipes/scilla-recipes/nonfungible.md",sourceDirName:"recipes/scilla-recipes",slug:"/recipes/scilla-recipes/nonfungible",permalink:"/recipes/scilla-recipes/nonfungible",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-recipes/nonfungible.md",tags:[{label:"non",permalink:"/tags/non"},{label:"fungible",permalink:"/tags/fungible"},{label:"token",permalink:"/tags/token"},{label:"reference",permalink:"/tags/reference"},{label:"contract",permalink:"/tags/contract"},{label:"zrc-1",permalink:"/tags/zrc-1"}],version:"current",frontMatter:{tags:["non","fungible","token","reference","contract","zrc-1"]},sidebar:"tutorialSidebar",previous:{title:"Natural numbers",permalink:"/recipes/scilla-recipes/natural"},next:{title:"Notable contracts",permalink:"/recipes/scilla-recipes/notable-contracts"}},u=[{value:"ZRC-6",id:"zrc-6",children:[]},{value:"Transferring Nonfungible Tokens",id:"transferring-nonfungible-tokens",children:[]},{value:"Further reading",id:"further-reading",children:[]}],p={toc:u};function f(e){var n=e.components,t=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"non-fungible-token"},"Non-fungible token"),(0,o.kt)("p",null,"A ",(0,o.kt)("a",{parentName:"p",href:"fungible"},"fungible token")," is unit of currency that can be readily interchanged, it has properties like fiat where 1 unit of currency is equal to 1 unit of the same currency."),(0,o.kt)("p",null,"Non-fungible tokens have associated with it some unique properties like some particular attributes, image, asset and therefore makes each piece unique. The tokens can be thought of as certificates of ownership for virtual or physical assets. A Non-Fungible contract is a collection of associations between token ids, there associated asset and an owning address."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-6.md"},"ZRC-6")," defines a minimum interface of an NFT smart contract. It has features including royalty payments and batch minting."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-7.md"},"ZRC-7")," defines a metadata standard that developers should follow to ensure ecosystem partners can universally consume. The resource attached to a ZRC-1 / ZRC-6 should emit a JSON response which contains not only the image, but the traits and other relevant project and token information."),(0,o.kt)("h3",{id:"zrc-6"},"ZRC-6"),(0,o.kt)("p",null,"The ZRC-6 contract can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/main/reference-contracts/zrc6.scilla"},"here"),"."),(0,o.kt)("p",null,"The ZRC-6 specification can be found ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-6.md"},"here"),"."),(0,o.kt)("h4",{id:"zrc-6-interface"},"ZRC-6 interface"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},"procedure TransferToken(to: ByStr20, token_id: Uint256)\ntransition Pause()\ntransition Unpause()\ntransition SetRoyaltyRecipient(to: ByStr20)\ntransition SetRoyaltyFeeBPS(fee_bps: Uint128)\ntransition SetBaseURI(uri: String)\ntransition Mint(to: ByStr20)\ntransition BatchMint(to_list: List ByStr20)\ntransition Burn(token_id: Uint256)\ntransition BatchBurn(token_id_list: List Uint256)\ntransition AddMinter(minter: ByStr20)\ntransition RemoveMinter(minter: ByStr20)\ntransition SetSpender(spender: ByStr20, token_id: Uint256)\ntransition AddOperator(operator: ByStr20)\ntransition RemoveOperator(operator: ByStr20)\ntransition TransferFrom(to: ByStr20, token_id: Uint256)\ntransition BatchTransferFrom(to_token_id_pair_list: List (Pair ByStr20 Uint256))\ntransition SetContractOwnershipRecipient(to: ByStr20)\ntransition AcceptContractOwnership()\n")),(0,o.kt)("h2",{id:"transferring-nonfungible-tokens"},"Transferring Nonfungible Tokens"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-ocaml"},'type TokenMove = | UserToContract | ContractToUser\n\nprocedure MoveNonFungibleTokenFromContractToUser(token_move: TokenMove, recipient_address: ByStr20, nonfungible: ByStr20, token_id: Uint256)\n  match token_move with\n    | ContractToUser =>\n      transfer_to_user = {\n        _tag: "TransferFrom";\n        _recipient: nonfungible;\n        _amount: uint128_zero;\n        to: recipient_address;\n        token_id: token_id\n        };\n      msgs = one_msg transfer_to_user;\n      send msgs;\n      e = {_eventname : "StoreMovedToUserSuccess"; nonfungible : nonfungible; token_id: token_id};\n      event e\n\n    | UserToContract =>\n    end\nend\n')),(0,o.kt)("h2",{id:"further-reading"},"Further reading"),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-1.md"},"ZRC-1 specification")),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/ZRC/blob/master/zrcs/zrc-6.md"},"ZRC-6 specification")))}f.isMDXComponent=!0}}]);