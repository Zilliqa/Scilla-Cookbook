"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[520],{3905:function(t,e,n){n.d(e,{Zo:function(){return u},kt:function(){return h}});var i=n(7294);function l(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function r(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);e&&(i=i.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,i)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?r(Object(n),!0).forEach((function(e){l(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function s(t,e){if(null==t)return{};var n,i,l=function(t,e){if(null==t)return{};var n,i,l={},r=Object.keys(t);for(i=0;i<r.length;i++)n=r[i],e.indexOf(n)>=0||(l[n]=t[n]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(i=0;i<r.length;i++)n=r[i],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(l[n]=t[n])}return l}var a=i.createContext({}),c=function(t){var e=i.useContext(a),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},u=function(t){var e=c(t.components);return i.createElement(a.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return i.createElement(i.Fragment,{},e)}},f=i.forwardRef((function(t,e){var n=t.components,l=t.mdxType,r=t.originalType,a=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),f=c(n),h=l,m=f["".concat(a,".").concat(h)]||f[h]||p[h]||r;return n?i.createElement(m,o(o({ref:e},u),{},{components:n})):i.createElement(m,o({ref:e},u))}));function h(t,e){var n=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=n.length,o=new Array(r);o[0]=f;var s={};for(var a in e)hasOwnProperty.call(e,a)&&(s[a]=e[a]);s.originalType=t,s.mdxType="string"==typeof t?t:l,o[1]=s;for(var c=2;c<r;c++)o[c]=n[c];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}f.displayName="MDXCreateElement"},507:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return s},contentTitle:function(){return a},metadata:function(){return c},toc:function(){return u},default:function(){return f}});var i=n(7462),l=n(3366),r=(n(7294),n(3905)),o=["components"],s={tags:["library","utilities","Util"]},a="Imports",c={unversionedId:"recipes/scilla-contract/imports",id:"recipes/scilla-contract/imports",isDocsHomePage:!1,title:"Imports",description:"To use functions from the standard library in a contract, the relevant library file must be imported using the import declaration.",source:"@site/docs/recipes/scilla-contract/imports.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/imports",permalink:"/recipes/scilla-contract/imports",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-contract/imports.md",tags:[{label:"library",permalink:"/tags/library"},{label:"utilities",permalink:"/tags/utilities"},{label:"Util",permalink:"/tags/util"}],version:"current",frontMatter:{tags:["library","utilities","Util"]},sidebar:"tutorialSidebar",previous:{title:"Fungible Token",permalink:"/recipes/scilla-contract/fungible"},next:{title:"Glossary of Keywords & Conventions",permalink:"/recipes/scilla-contract/keywords"}},u=[{value:"Functions",id:"functions",children:[]},{value:"PairUtils",id:"pairutils",children:[]},{value:"BoolUtils",id:"boolutils",children:[]},{value:"IntUtils",id:"intutils",children:[]},{value:"ListUtils",id:"listutils",children:[]},{value:"NatUtils",id:"natutils",children:[]},{value:"Further Reading",id:"further-reading",children:[]}],p={toc:u};function f(t){var e=t.components,n=(0,l.Z)(t,o);return(0,r.kt)("wrapper",(0,i.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"imports"},"Imports"),(0,r.kt)("p",null,"To use functions from the standard library in a contract, the relevant library file must be imported using the import declaration."),(0,r.kt)("p",null,"The following code snippet shows how to import the functions from the ListUtils and IntUtils libraries:"),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("p",null,"You can find all the typical functions available to the scilla checker and compiler ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/scilla-compiler/tree/master/src/stdlib"},"here"),". A typical query is asking about Integer '>=' or '<=' as these are different to the ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin lt")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"builtin gt"),"."),(0,r.kt)("p",null,"We can find all of the wrappers for the Int class in the above link ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/Zilliqa/scilla-compiler/blob/master/src/stdlib/IntUtils.scillib"},"for the IntUtils")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"uint128_le\nuint128_ge\nuint128_gt\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"import ListUtils IntUtils (* builtin library function *)\n\nlibrary ExampleLib (* Your library definitions for variables and functions*)\n\ncontract Example() (* your consumation of said library definitions *)\n")),(0,r.kt)("h2",{id:"pairutils"},"PairUtils"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"fst : Pair 'A 'B -> 'A: Extract the first element of a Pair.\nsnd : Pair 'A 'B -> 'B: Extract the second element of a Pair.\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"procedure Minting(input_pair: Pair ByStr20 String)\n  to = let fst_string_bystr20 = @fst ByStr20 String in\n    fst_string_bystr20 input_pair;\n  token_uri = let snd_string_bystr20 = @snd ByStr20 String in\n    snd_string_bystr20 input_pair;\n")),(0,r.kt)("h2",{id:"boolutils"},"BoolUtils"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},'andb : Bool -> Bool -> Bool: Computes the logical AND of two Bool values.\norb  : Bool -> Bool -> Bool: Computes the logical OR of two Bool values.\nnegb : Bool -> Bool: Computes the logical negation of a Bool value.\nbool_to_string : Bool -> String: Transforms a Bool value into a String value. True is transformed into "True", and False is transformed into "False".\n')),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"procedure IsOwnerOrOperator(token_owner: ByStr20)\n  is_owner = builtin eq _sender token_owner;\n  is_approved_for_all <- exists operator_approvals[token_owner][_sender];\n  is_authorised = orb is_owner is_approved_for_all;\n")),(0,r.kt)("h2",{id:"intutils"},"IntUtils"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"intX_eq : IntX -> IntX -> Bool: \nEquality operator specialised for each IntX type.\n\nuintX_eq : UintX -> UintX -> Bool: \nEquality operator specialised for each UintX type.\n\nintX_lt : IntX -> IntX -> Bool: \nLess-than operator specialised for each IntX type.\n\nuintX_lt : UintX -> UintX -> Bool:\nLess-than operator specialised for each UintX type.\n\nintX_neq : IntX -> IntX -> Bool:\n Not-equal operator specialised for each IntX type.\n\nuintX_neq : UintX -> UintX -> Bool:\n Not-equal operator specialised for each UintX type.\n\nintX_le : IntX -> IntX -> Bool:\n Less-than-or-equal operator specialised for each IntX type.\n\nuintX_le : UintX -> UintX -> Bool:\n Less-than-or-equal operator specialised for each UintX type.\n\nintX_gt : IntX -> IntX -> Bool: \nGreater-than operator specialised for each IntX type.\n\nuintX_gt : UintX -> UintX -> Bool:\n Greater-than operator specialised for each UintX type.\n\nintX_ge : IntX -> IntX -> Bool: \nGreater-than-or-equal operator specialised for each IntX type.\n\nuintX_ge : UintX -> UintX -> Bool: \nGreater-than-or-equal operator specialised for each UintX type.\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let a = Int32 100 in\nlet b = Int32 2 in\nlet c = Int32 40 in\n\nlet a_gt_b = int32_gt a b in\nlet a_ge_a = int32_ge a a in\nlet a_le_b = int32_le a b in\nlet a_lt_c = int32_lt a c in\nlet c_eq_a = int32_eq c a in\nlet b_neq_c = int32_neq b c \n")),(0,r.kt)("h2",{id:"listutils"},"ListUtils"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"list_map : ('A -> 'B) -> List 'A -> : List 'B.\nApply f : 'A -> 'B to every element of l : List 'A, \nconstructing a list (of type List 'B) of the results.\n\nlist_filter : ('A -> Bool) -> List 'A -> List 'A.\nFilter out elements on the list based on the predicate f : 'A -> Bool. \nIf an element satisfies f, it will be in the resultant list, \notherwise it is removed. The order of the elements is preserved.\n\nlist_append : (List 'A -> List 'A ->  List 'A). \nReturn the head element of a list l : List 'A as an optional value. \nIf l is not empty with the first element h, \nthe result is Some h. If l is empty, then the result is None.\n\nlist_head : (List 'A) -> (Option 'A).\nReturn the head element of a list l : List 'A as an optional value. \nIf l is not empty with the first element h,\nthe result is Some h. If l is empty, then the result is None.\n\nlist_tail : (List 'A) -> (Option List 'A).\nReturn the tail of a list l : List 'A as an optional value.\nIf l is a non-empty list of the form Cons h t,\nthen the result is Some t. If l is empty, then the result is None.\n\nlist_foldl_while : ('B -> 'A -> Option 'B) -> 'B -> List 'A -> 'B\nGiven a function f : 'B -> 'A -> Option 'B, accumulator z : 'B and list ls : List 'A \nexecute a left fold when our given function returns Some x : Option 'B using f z x : 'B or list is empty\nbut in the case of None : Option 'B terminate early, returning z.\n\nlist_append : (List 'A -> List 'A ->  List 'A).\nAppend the first list to the front of the second list, keeping the order of the elements in both lists.\nNote that list_append has linear time complexity in the length of the first argument list.\n\nlist_reverse : (List 'A -> List 'A).\nReturn the reverse of the input list. Note that list_reverse has linear time complexity in the length of the argument list.\n\nlist_flatten : (List List 'A) -> List 'A.\nConstruct a list of all the elements in a list of lists. \nEach element (which has type List 'A) of the input list (which has type List List 'A) \nare all concatenated together, keeping the order of the input list. \nNote that list_flatten has linear time complexity in the total number of elements in all of the lists.\n\nlist_length : List 'A -> Uint32\nCount the number of elements in a list. Note that list_length has linear time complexity in the number of elements in the list.\n\nlist_eq : ('A -> 'A -> Bool) -> List 'A -> List 'A -> Bool.\nCompare two lists element by element, using a predicate function f : 'A -> 'A -> Bool. If f returns True for every pair of elements, then list_eq returns True. If f returns False for at least one pair of elements, or if the lists have different lengths, then list_eq returns False.\n\nlist_mem : ('A -> 'A -> Bool) -> 'A -> List 'A -> Bool.\nChecks whether an element a : 'A is an element in the list l : List'A.\nf : 'A -> 'A -> Bool should be provided for equality comparison.\n\nlist_forall : ('A -> Bool) -> List 'A -> Bool.\nCheck whether all elements of list l : List 'A satisfy the predicate f : 'A -> Bool.\nlist_forall returns True if all elements satisfy f, and False if at least one element does not satisfy f.\n\nlist_exists : ('A -> Bool) -> List 'A -> Bool.\nCheck whether at least one element of list l : List 'A satisfies the predicate f : 'A -> Bool.\nlist_exists returns True if at least one element satisfies f, and False if none of the elements satisfy f.\n\nlist_sort : ('A -> 'A -> Bool) -> List 'A -> List 'A.\nSort the input list l : List 'A using insertion sort. \nThe comparison function flt : 'A -> 'A -> Bool provided must return True if its first argument is less than its second argument.\nlist_sort has quadratic time complexity.\n\nlist_find : ('A -> Bool) -> List 'A -> Option 'A.\nReturn the first element in a list l : List 'A satisfying the predicate f : 'A -> Bool. If at least one element in the list satisfies the predicate, and the first one of those elements is x, then the result is Some x. If no element satisfies the predicate, the result is None.\n\nlist_zip : List 'A -> List 'B -> List (Pair 'A 'B).\nCombine two lists element by element, resulting in a list of pairs. If the lists have different lengths, the trailing elements of the longest list are ignored.\n\nlist_zip_with : ('A -> 'B -> 'C) -> List 'A -> List 'B -> List 'C ).\nCombine two lists element by element using a combining function f : 'A -> 'B -> 'C.\nThe result of list_zip_with is a list of the results of applying f to the elements of the two lists. \nIf the lists have different lengths, the trailing elements of the longest list are ignored.\n\nlist_unzip : List (Pair 'A 'B) -> Pair (List 'A) (List 'B).\nSplit a list of pairs into a pair of lists consisting of the elements of the pairs of the original list.\n\nlist_nth : Uint32 -> List 'A -> Option 'A.\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"let int_append = @list_append Int32 in\n\nlet one = Int32 1 in\nlet two = Int32 2 in\nlet ten = Int32 10 in\nlet eleven = Int32 11 in\n\nlet nil = Nil {Int32} in\nlet l1 = Cons {Int32} eleven nil in\nlet l2 = Cons {Int32} ten l1 in\nlet l3 = Cons {Int32} two l2 in\nlet l4 = Cons {Int32} one l3 in\n\nint_append  l4 l2\n")),(0,r.kt)("h2",{id:"natutils"},"NatUtils"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ocaml"},"nat_prev : Nat -> Option Nat: \nReturn the Peano number one less than the current one. \nIf the current number is Zero, the result is None. If the current number is Succ x, then the result is Some x.\n\nnat_fold_while : ('T -> Nat -> Option 'T) -> 'T -> Nat -> 'T: Takes arguments f : 'T -> Nat -> Option 'T, z : `T and m : Nat. \nThis is nat_fold with early termination. Continues recursing so long as f returns Some y with new accumulator y. \nOnce f returns None, the recursion terminates.\n\nis_some_zero : Nat -> Bool: \nZero check for Peano numbers.\n\nnat_eq : Nat -> Nat -> Bool: \nEquality check specialised for the Nat type.\n\nnat_to_int : Nat -> Uint32: \nConvert a Peano number to its equivalent Uint32 integer.\n\nuintX_to_nat : UintX -> Nat: Convert a UintX integer to its equivalent Peano number. \nThe integer must be small enough to fit into a Uint32. If it is not, then an overflow error will occur.\n\nintX_to_nat : IntX -> Nat: Convert an IntX integer to its equivalent Peano number.\nThe integer must be non-negative, and must be small enough to fit into a Uint32. If it is not, then an underflow or overflow error will occur.\n")),(0,r.kt)("h2",{id:"further-reading"},"Further Reading"))}f.isMDXComponent=!0}}]);