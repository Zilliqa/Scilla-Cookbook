"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4298],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=c(n),m=a,f=d["".concat(s,".").concat(m)]||d[m]||p[m]||i;return n?r.createElement(f,o(o({ref:t},u),{},{components:n})):r.createElement(f,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6793:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return d}});var r=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],l={tags:["folding","recursion","iterate"]},s="Recursion",c={unversionedId:"recipes/scilla-contract/folding",id:"recipes/scilla-contract/folding",isDocsHomePage:!1,title:"Recursion",description:"Recursion in Scilla takes some collection type with a begining and end like a Natural number or the entries of a finite List and can process some logic based on that.",source:"@site/docs/recipes/scilla-contract/folding.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/folding",permalink:"/recipes/scilla-contract/folding",editUrl:"https://github.com/Zilliqa/Scilla-Cookbook/tree/master/docs/recipes/scilla-contract/folding.md",tags:[{label:"folding",permalink:"/tags/folding"},{label:"recursion",permalink:"/tags/recursion"},{label:"iterate",permalink:"/tags/iterate"}],version:"current",frontMatter:{tags:["folding","recursion","iterate"]},sidebar:"tutorialSidebar",previous:{title:"Decentralised Exchange (DEX)",permalink:"/recipes/scilla-contract/dex"},next:{title:"Functions",permalink:"/recipes/scilla-contract/functions"}},u=[{value:"forall List entries, call procedure",id:"forall-list-entries-call-procedure",children:[]},{value:"Fibonacci folding example",id:"fibonacci-folding-example",children:[]},{value:"Further Reading",id:"further-reading",children:[]}],p={toc:u};function d(e){var t=e.components,n=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"recursion"},"Recursion"),(0,i.kt)("p",null,"Recursion in Scilla takes some collection type with a begining and end like a Natural number or the entries of a finite List and can process some logic based on that."),(0,i.kt)("h2",{id:"forall-list-entries-call-procedure"},"forall List entries, call procedure"),(0,i.kt)("p",null,"Lets assume we are dealing with a  ",(0,i.kt)("inlineCode",{parentName:"p"},"Map of ByStr20 Uint128"),". This map stores user wallets to token account values."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let user_map : Map ByStr20 Uint128 = Emp ByStr20 Uint128\n")),(0,i.kt)("p",null,"We want to create some functionality to do something to these entries, our example usecase will be give every user in the Map a singular token everytime a Transition is called."),(0,i.kt)("p",null,"We cannot use a ",(0,i.kt)("inlineCode",{parentName:"p"},"Map")," directly in foralls, but we can use the builtin ",(0,i.kt)("inlineCode",{parentName:"p"},"builtin to_list map_name")," to return us a list based on the current state of the map. We can use this to iterate, this will cost gas for the conversion equal to the elements being transformed from Map entry into List entry. When ",(0,i.kt)("inlineCode",{parentName:"p"},"RewardEveryoneOneToken")," passes  ",(0,i.kt)("inlineCode",{parentName:"p"},"user_map_as_list")," to ",(0,i.kt)("inlineCode",{parentName:"p"},"GiveReward")," it passes each element as a ",(0,i.kt)("inlineCode",{parentName:"p"},"Pair ByStr20 Uint128")," to which the developer then parses these types out to use them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"transition RewardEveryoneOneToken()\n  (* read the whole map *)\n  full_read_user_map <- user_map;\n\n  (* convert each Map element to a List *)\n  user_map_as_list =  builtin to_list full_read_user_map;\n\n  (* when we iterate a MappedList, it's passed as a Pair of map_key, map_value*)\n  forall user_map_as_list GiveReward;\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let uint128_one = Uint128 1\n\nprocedure GiveReward(user_amount_pair : Pair ByStr20 Uint128)\n (* get the first value of a Pair of ByStr20 Uint128 *)\n  user_address =\n    let fst_user_address = @fst ByStr20 Uint128 in\n      fst_user_address user_amount_pair;\n\n (* get the second value of a Pair of ByStr20 Uint128 *)\n  user_amount =\n    let snd_user_amount = @snd ByStr20 Uint128 in\n      snd_user_amount user_amount_pair;\n\n  (* user_amount += 1 *)\n  user_amount_plus_rewards = builtin add user_amount uint128_one;\n\n  (* set this value in state *)\n  user_map[user_address] := user_amount_plus_rewards\nend\n")),(0,i.kt)("h2",{id:"fibonacci-folding-example"},"Fibonacci folding example"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let fib = fun (n : Nat) =>\n  let iter_fun =\n    fun (res : Product Int Int) => fun (n: Nat) =>\n      match res with\n      | Pair x y => let z = builtin add x y in Pair {Int Int} z x\n      end\n    in\n  let zero = 0 in\n  let one = 1 in\n  let init_val = Pair {Int Int} one zero in\n  let typed_folder = @nat_fold (Product Int Int) in\n  let folder = typed_folder iter_fun init_val in\n  let res = folder n in\n  match res with | Pair x y => x end\n")),(0,i.kt)("h2",{id:"further-reading"},"Further Reading"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://github.com/TheDrBee/oSCILLAtor/blob/main/contracts/Recursion.scilla"},"TheDrBee - Recursion.scilla")))}d.isMDXComponent=!0}}]);