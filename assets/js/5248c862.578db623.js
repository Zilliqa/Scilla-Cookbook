"use strict";(self.webpackChunkdocu_scilla=self.webpackChunkdocu_scilla||[]).push([[4104],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=c(n),m=r,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,o=new Array(i);o[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},3205:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(7462),r=n(3366),i=(n(7294),n(3905)),o=["components"],l={tags:["adt","polymorphic","complex","composite","user","custom","types","algebraic"]},s="ADT",c={unversionedId:"recipes/scilla-contract/adt",id:"recipes/scilla-contract/adt",isDocsHomePage:!1,title:"ADT",description:"Algebraic Data Types",source:"@site/docs/recipes/scilla-contract/adt.md",sourceDirName:"recipes/scilla-contract",slug:"/recipes/scilla-contract/adt",permalink:"/recipes/scilla-contract/adt",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/recipes/scilla-contract/adt.md",tags:[{label:"adt",permalink:"/tags/adt"},{label:"polymorphic",permalink:"/tags/polymorphic"},{label:"complex",permalink:"/tags/complex"},{label:"composite",permalink:"/tags/composite"},{label:"user",permalink:"/tags/user"},{label:"custom",permalink:"/tags/custom"},{label:"types",permalink:"/tags/types"},{label:"algebraic",permalink:"/tags/algebraic"}],version:"current",frontMatter:{tags:["adt","polymorphic","complex","composite","user","custom","types","algebraic"]},sidebar:"tutorialSidebar",previous:{title:"Addresses",permalink:"/recipes/scilla-contract/addresses"},next:{title:"BNum",permalink:"/recipes/scilla-contract/bnum"}},p=[{value:"Algebraic Data Types",id:"algebraic-data-types",children:[{value:"Bool",id:"bool",children:[]},{value:"Option",id:"option",children:[]},{value:"List",id:"list",children:[]},{value:"Pair",id:"pair",children:[]},{value:"Nat",id:"nat",children:[]},{value:"User-defined",id:"user-defined",children:[]}]},{value:"Full ADT examples",id:"full-adt-examples",children:[{value:"Parcel",id:"parcel",children:[]},{value:"PlayerAge",id:"playerage",children:[]}]},{value:"Further Reading",id:"further-reading",children:[]}],d={toc:p};function u(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"adt"},"ADT"),(0,i.kt)("h2",{id:"algebraic-data-types"},"Algebraic Data Types"),(0,i.kt)("p",null,"In functional programming and type theory, an algebraic data type (ADT) is a kind of composite type, formed of two or more other primative types."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type MyAdt =\n  | MyConstructor1 of Int32 String\n  | MyConstructor2 of ByStr20\n  | MyConstructor3\n")),(0,i.kt)("p",null,"An ADT is defined using one or more constructors (not to be confused with constructors from object-oriented languages). A value of type MyAdt is constructed using exactly one of these constructors. In this example, a MyAdt value constructed using MyConstructor1 will contain a tuple comprised of an Int32 value and a String value. A MyAdt value constructed using MyConstructor3 on the other hand will not contain any further values inside it."),(0,i.kt)("p",null,"The example we saw previously defines an ADT whose composite types are fixed. A polymorphic ADT allows using type variables in place of concrete constituent types, for substitution later. Let's see an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'A MyPAdt =\n  | MyPConstructor1 of 'A String\n  | MyPConstructor2 of ByStr20\n  | MyPConstructor3\n")),(0,i.kt)("p",null,"MyPAdt is a polymorphic ADT with a type parameter (variable) 'A. When MyPAdt is, for example, instantiated with the type parameter 'A set to Int32, then MyPAdt will be the same as MyAdt. List, the Scilla built-in ADT is, for example, a polymorphic ADT. When we write List Int32, it means that we have instantiated List ADT with Int32. This in-built ADT, if it wasn't in-built, would look like."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type 'A List =\n  | Cons of 'A ('A List)\n  | Nil\n")),(0,i.kt)("p",null,"At the moment, Scilla does not support user-defined polymorphic ADTs. Only the in-built ADTs List, Pair and Option are polymorphic. Users can define concrete ADTs such as MyAdt."),(0,i.kt)("h3",{id:"bool"},"Bool"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"my_bool = True\n")),(0,i.kt)("h3",{id:"option"},"Option"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"let none_value = None {String}\n\nlet some_value = (* setup Option variable *)\n  let ten = Int32 10 in (* setup variable 10 and chain to next line *)\n  Some {Int32} ten (* create Option variable of type Int32 with Some value 10*)\n")),(0,i.kt)("h3",{id:"list"},"List"),(0,i.kt)("h3",{id:"pair"},"Pair"),(0,i.kt)("h3",{id:"nat"},"Nat"),(0,i.kt)("h3",{id:"user-defined"},"User-defined"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type SwapDirection = | ZilToToken | TokenToZil\n\nprocedure Example(direction: SwapDirection)\n    match direction with\n      | ZilToToken => \n      | TokenToZil => \n    end\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type Pool = | Pool of Uint128 Uint128 \n\nprocedure Example(pool: Pool)\n  match pool with\n    | Pool x y =>\n  end\nend\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"type Game = | Game of (Option ByStr20) Uint128\n\nprocedure Example(game: Game)\n  match game with\n    | Game maybe_bystr game_int =>\n      (* At this point you have the Optional and the int value*)\n      match maybe_bystr with\n        | Some some_bystr =>\n          (* At this point you have Some bystr20 value and the int value *)\n        | None =>\n          (* At this point you have only the int value*)\n      end\n  end\nend\n")),(0,i.kt)("h2",{id:"full-adt-examples"},"Full ADT examples"),(0,i.kt)("h3",{id:"parcel"},"Parcel"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},'scilla_version 0\n(****************************************************************************)\n(*   user defined algebraic data type (ADT) examples:                       *)\n(*   a Parcel with a content consisting of one or two Item(s)               *)\n(*   A single Item can be a Shirt or a Barbell and has a weight             *)\n(*   A Parcel can have one Item or two Items in it and depending on the     *)\n(*   total weight has a cost to ship assigned to it                         *)\n(****************************************************************************)\nlibrary Adt\n\ntype Item = (* constructor argument is the weight of the item *)\n  | Shirt of Uint32\n  | Barbell of Uint32\n\ntype Parcel =\n  | OneContent of Item (* a parcel with a single item as content *)\n  | TwoContents of Item Item (* a parcel can be filled with 2 items *)\n\nlet weight_of_item = fun(i: Item) => (* how much an item weighs *)\n  match i with\n  | Shirt w => w\n  | Barbell w => w\n  end\n\nlet cost_per_weight = Uint32 5\n\nlet cost_of_parcel = fun(p: Parcel) => (* cost to ship the parcel *)\n  let weight =\n    match p with\n    | OneContent c => (* parcel has only one item as content *)\n        weight_of_item c\n    | TwoContents c1 c2 => (* parcel has two items as content *)\n        let w1 = weight_of_item c1 in\n        let w2 = weight_of_item c2 in\n        builtin add w1 w2 (* total weight is sum of the two *)\n    end in\n  builtin mul weight cost_per_weight (* cost is total weight times cost_per_weight *)\n\n\ncontract Adt\n()\n\n(* mutable fields declarations *)\nfield parcels : List (Pair Parcel Uint32) = Nil {(Pair Parcel Uint32)} (* a list of parcels and their cost to ship *)\n\nprocedure ComputeCostAndAdd(p: Parcel)\n  (* compute cost to ship the new parcel *)\n  cost = cost_of_parcel p;\n  (* add it to the list of parcels *)\n  l <- parcels;\n  pair = Pair {Parcel Uint32} p cost;\n  new_list = Cons {(Pair Parcel Uint32)} pair l; (* front insert *)\n  parcels := new_list;\n  ev = {_eventname : "AddToListOfParcelsSuccess"; cost_to_ship: cost; parcels: new_list};\n  event ev\nend\n\n(* add parcels with different items to the list of parcels *)\ntransition AddParcelWithShirt(weight: Uint32)\n  c = Shirt weight;\n  p = OneContent c;\n  ComputeCostAndAdd p\nend\n\ntransition AddParcelWithBarbell(weight: Uint32)\n  c = Barbell weight;\n  p = OneContent c;\n  ComputeCostAndAdd p\nend\n\ntransition AddParcelWithTwoShirts(weight1: Uint32, weight2: Uint32)\n  c1 = Shirt weight1;\n  c2 = Shirt weight2;\n  p = TwoContents c1 c2;\n  ComputeCostAndAdd p\nend\n\ntransition AddParcelWithShirtAndBarbell(weightS: Uint32, weightB: Uint32)\n  c1 = Shirt weightS;\n  c2 = Barbell weightB;\n  p = TwoContents c1 c2;\n  ComputeCostAndAdd p\nend\n')),(0,i.kt)("h3",{id:"playerage"},"PlayerAge"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ocaml"},"scilla_version 0\n(************************************************************************)\n(* a map of ByStr20 (address) to a user defined algebraic data type     *)\n(*   the ADT is a Player with an age that either plays tennis or runs   *)\n(************************************************************************)\nlibrary AdtMap\n\ntype Sport =\n  | Tennis\n  | Run\n\ntype Player = (* Age and preferred Sport *)\n  | Player of Uint32 Sport\n\n\ncontract AdtMap\n()\n\n(* mutable fields declarations *)\nfield players : Map ByStr20 Player = Emp ByStr20 Player (* players[address] = Player *)\n\nprocedure Add(age: Uint32, sport: Sport)\n  player = Player age sport;\n  players[_sender] := player\nend\n\n(* add sender as a Tennis player *)\ntransition AddTennis(age: Uint32)\n  sport = Tennis;\n  Add age sport\nend\n(* add sender as a Soccer player *)\ntransition AddRun(age: Uint32)\n  sport = Run;\n  Add age sport\nend\n(* change the age of sender, kepp its sport *)\ntransition ChangeAge(new_age: Uint32)\n  player_o <- players[_sender]; (* look up in map *)\n  match player_o with\n  | Some player =>\n    match player with (* get the entries and change age *)\n    | Player age sport =>\n      new_player = Player new_age sport;\n      players[_sender] := new_player\n    end (* player *)\n  | None => (* sender is not in map, don't do anything *)\n  end (* player_o *)\nend\n(* remove the sender from the map *)\ntransition Remove()\n  delete players[_sender]\nend\n")),(0,i.kt)("h2",{id:"further-reading"},"Further Reading"))}u.isMDXComponent=!0}}]);